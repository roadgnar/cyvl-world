<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ROAD RECKONING: Pavement Strike Force</title>
<script defer src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script defer src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
<script defer src="/shared/leaderboard.js"></script>
<script defer src="/shared/arcade-nav.js"></script>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #0a0a1a;
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  font-family: 'Courier New', monospace;
  overflow: hidden;
  color: #00e5ff;
  user-select: none;
}
#game-container {
  position: relative;
  width: 1024px;
  height: 700px;
  border: 1px solid #00e5ff33;
  box-shadow: 0 0 30px #00e5ff22, inset 0 0 30px #00e5ff08;
  overflow: hidden;
  cursor: crosshair;
}
canvas#scene {
  display: block;
  width: 1024px;
  height: 700px;
  image-rendering: auto;
}
#scanlines {
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  background: repeating-linear-gradient(
    0deg,
    transparent,
    transparent 2px,
    rgba(0,0,0,0.08) 2px,
    rgba(0,0,0,0.08) 4px
  );
  pointer-events: none;
  z-index: 100;
}
#crt-flicker {
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  pointer-events: none;
  z-index: 99;
  background: radial-gradient(ellipse at center, transparent 60%, rgba(0,0,0,0.4) 100%);
}
#hud-top {
  position: absolute;
  top: 0; left: 0; right: 0;
  height: 44px;
  background: linear-gradient(180deg, rgba(0,10,20,0.95) 0%, rgba(0,10,20,0.7) 100%);
  border-bottom: 1px solid #00e5ff44;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0 16px;
  font-size: 14px;
  z-index: 50;
  pointer-events: none;
}
#hud-top .hud-item {
  display: flex;
  align-items: center;
  gap: 8px;
}
#hud-top .hud-label {
  color: #00e5ff88;
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: 1px;
}
#hud-top .hud-value {
  color: #00e5ff;
  font-weight: bold;
  font-size: 16px;
}
#hud-bottom {
  position: absolute;
  bottom: 0; left: 0; right: 0;
  height: 40px;
  background: linear-gradient(0deg, rgba(0,10,20,0.95) 0%, rgba(0,10,20,0.7) 100%);
  border-top: 1px solid #00e5ff44;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0 16px;
  font-size: 13px;
  z-index: 50;
  pointer-events: none;
}
.combo-glow-1 { text-shadow: 0 0 4px #00e5ff; }
.combo-glow-2 { text-shadow: 0 0 8px #00ff88, 0 0 16px #00ff88; color: #00ff88 !important; }
.combo-glow-3 { text-shadow: 0 0 12px #ffd700, 0 0 24px #ff6600; color: #ffd700 !important; }
.combo-glow-4 { text-shadow: 0 0 16px #ff2244, 0 0 32px #ff2244, 0 0 48px #ff6600; color: #ff2244 !important; }
#overlay {
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 80;
  pointer-events: auto;
}
#overlay.hidden { display: none; pointer-events: none; }
.screen { display: none; flex-direction: column; align-items: center; text-align: center; }
.screen.active { display: flex; }
.btn {
  background: transparent;
  border: 1px solid #00e5ff;
  color: #00e5ff;
  font-family: 'Courier New', monospace;
  font-size: 14px;
  padding: 10px 28px;
  cursor: pointer;
  text-transform: uppercase;
  letter-spacing: 2px;
  transition: all 0.2s;
  margin: 6px;
}
.btn:hover {
  background: #00e5ff22;
  box-shadow: 0 0 15px #00e5ff44;
  text-shadow: 0 0 8px #00e5ff;
}
.btn-green { border-color: #00ff88; color: #00ff88; }
.btn-green:hover { background: #00ff8822; box-shadow: 0 0 15px #00ff8844; }
.btn-red { border-color: #ff2244; color: #ff2244; }
.btn-red:hover { background: #ff224422; box-shadow: 0 0 15px #ff224444; }
.btn-orange { border-color: #ff6600; color: #ff6600; }
.btn-orange:hover { background: #ff660022; box-shadow: 0 0 15px #ff660044; }
.mode-btn {
  width: 220px;
  padding: 14px 20px;
  margin: 8px;
  text-align: left;
  position: relative;
}
.mode-btn .mode-name { font-size: 16px; font-weight: bold; display: block; }
.mode-btn .mode-desc { font-size: 10px; color: #00e5ff88; display: block; margin-top: 4px; }
h1 { font-size: 42px; letter-spacing: 6px; margin-bottom: 4px; text-shadow: 0 0 20px #00e5ff66; }
h2 { font-size: 22px; letter-spacing: 3px; margin-bottom: 16px; }
h3 { font-size: 16px; letter-spacing: 2px; margin-bottom: 12px; color: #00e5ff; }
.subtitle { color: #00ff88; font-size: 14px; letter-spacing: 4px; margin-bottom: 30px; }
.typewriter { font-size: 13px; color: #aaccee; max-width: 600px; line-height: 1.6; margin-bottom: 24px; min-height: 80px; }
.blink { animation: blink 1s step-end infinite; }
@keyframes blink { 50% { opacity: 0; } }
.press-start { font-size: 18px; letter-spacing: 4px; margin-top: 40px; }
.countdown { font-size: 120px; font-weight: bold; text-shadow: 0 0 40px #00e5ff, 0 0 80px #00e5ff44; }
.grade-display { font-size: 100px; font-weight: bold; margin: 16px 0; }
.grade-S { color: #ffd700; text-shadow: 0 0 30px #ffd700, 0 0 60px #ff6600; }
.grade-A { color: #00ff88; text-shadow: 0 0 30px #00ff88; }
.grade-B { color: #00e5ff; text-shadow: 0 0 20px #00e5ff; }
.grade-C { color: #ff6600; text-shadow: 0 0 20px #ff6600; }
.grade-D { color: #ff2244; text-shadow: 0 0 20px #ff2244; }
.grade-F { color: #ff2244; text-shadow: 0 0 30px #ff2244, 0 0 60px #880000; }
.stats-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px 32px;
  font-size: 13px;
  margin: 16px 0;
  text-align: left;
}
.stats-grid .stat-label { color: #00e5ff88; }
.stats-grid .stat-value { color: #00e5ff; font-weight: bold; }
.btn-row { display: flex; gap: 8px; margin-top: 16px; flex-wrap: wrap; justify-content: center; }
#popup {
  position: absolute;
  display: none;
  background: rgba(0,10,20,0.95);
  border: 1px solid #00e5ff;
  padding: 8px;
  z-index: 90;
  box-shadow: 0 0 20px #00e5ff44;
}
#popup .popup-btn {
  display: block;
  width: 100%;
  background: transparent;
  border: 1px solid #00e5ff44;
  color: #00e5ff;
  font-family: 'Courier New', monospace;
  font-size: 12px;
  padding: 6px 16px;
  cursor: pointer;
  margin: 3px 0;
  text-align: left;
}
#popup .popup-btn:hover {
  background: #00e5ff22;
  border-color: #00e5ff;
}
#confirm-btns {
  position: absolute;
  display: none;
  z-index: 90;
}
#confirm-btns .cbtn {
  display: inline-block;
  width: 40px;
  height: 40px;
  line-height: 40px;
  text-align: center;
  font-size: 20px;
  cursor: pointer;
  border: 1px solid;
  margin: 0 4px;
  font-family: 'Courier New', monospace;
}
#confirm-btns .cbtn-yes {
  border-color: #00ff88;
  color: #00ff88;
  background: rgba(0,255,136,0.1);
}
#confirm-btns .cbtn-yes:hover { background: rgba(0,255,136,0.3); }
#confirm-btns .cbtn-no {
  border-color: #ff2244;
  color: #ff2244;
  background: rgba(255,34,68,0.1);
}
#confirm-btns .cbtn-no:hover { background: rgba(255,34,68,0.3); }
#click-effects {
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  pointer-events: none;
  z-index: 70;
}
#pause-menu {
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.8);
  display: none;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 110;
}
#pause-menu.active { display: flex; }
</style>
</head>
<body>
<div id="game-container">
  <canvas id="scene" width="1024" height="700"></canvas>
  <div id="scanlines"></div>
  <div id="crt-flicker"></div>
  <div id="hud-top" style="display:none;">
    <div class="hud-item">
      <span class="hud-label">MODE</span>
      <span class="hud-value" id="hud-mode">ELIMINATE</span>
    </div>
    <div class="hud-item">
      <span class="hud-label">SCENE</span>
      <span class="hud-value" id="hud-scene">1/15</span>
    </div>
    <div class="hud-item">
      <span class="hud-label">TIMER</span>
      <span class="hud-value" id="hud-timer">60</span>
    </div>
    <div class="hud-item">
      <span class="hud-label">SCORE</span>
      <span class="hud-value" id="hud-score">0</span>
    </div>
  </div>
  <div id="hud-bottom" style="display:none;">
    <div class="hud-item">
      <span class="hud-label">COMBO</span>
      <span class="hud-value" id="hud-combo">x1</span>
    </div>
    <div class="hud-item">
      <span class="hud-label">STREAK</span>
      <span class="hud-value" id="hud-streak">0</span>
    </div>
    <div class="hud-item">
      <span class="hud-label">ACCURACY</span>
      <span class="hud-value" id="hud-accuracy">100%</span>
    </div>
  </div>
  <div id="overlay">
    <!-- TITLE SCREEN -->
    <div class="screen active" id="screen-title">
      <h1>ROAD RECKONING</h1>
      <div class="subtitle">PAVEMENT STRIKE FORCE</div>
      <div style="color:#aaccee; font-size:12px; margin-bottom:20px; max-width:500px; line-height:1.5;">
        QA Annotation Division // cyvl.ai<br>
        Classify. Eliminate. Discover. Confirm.
      </div>
      <div class="press-start blink" id="press-start">[ PRESS START ]</div>
    </div>
    <!-- BRIEFING SCREEN -->
    <div class="screen" id="screen-briefing">
      <h2>MISSION BRIEFING</h2>
      <div class="typewriter" id="briefing-text"></div>
      <h3>SELECT MISSION TYPE</h3>
      <div style="display:flex; flex-wrap:wrap; justify-content:center;">
        <button class="btn mode-btn" data-mode="ELIMINATE">
          <span class="mode-name">ELIMINATE</span>
          <span class="mode-desc">Remove incorrect annotations. 60s.</span>
        </button>
        <button class="btn mode-btn" data-mode="DISCOVER">
          <span class="mode-name">DISCOVER</span>
          <span class="mode-desc">Find missing annotations. 60s.</span>
        </button>
        <button class="btn mode-btn" data-mode="RECLASSIFY">
          <span class="mode-name">RECLASSIFY</span>
          <span class="mode-desc">Fix mislabeled annotations. 90s.</span>
        </button>
        <button class="btn mode-btn" data-mode="CONFIRM">
          <span class="mode-name">CONFIRM</span>
          <span class="mode-desc">Judge all annotations. 120s.</span>
        </button>
      </div>
    </div>
    <!-- DEPLOY SCREEN -->
    <div class="screen" id="screen-deploy">
      <h3 id="deploy-mode">ELIMINATE MODE</h3>
      <div style="color:#aaccee; font-size:12px; margin-bottom:20px;">DEPLOYING TO SECTOR...</div>
      <div class="countdown" id="countdown">3</div>
    </div>
    <!-- GAMEPLAY (overlay hidden during play) -->
    <div class="screen" id="screen-gameplay"></div>
    <!-- DEBRIEF SCREEN -->
    <div class="screen" id="screen-debrief">
      <h2>MISSION DEBRIEF</h2>
      <div id="debrief-grade" class="grade-display grade-S">S</div>
      <div class="stats-grid" id="debrief-stats"></div>
      <div class="btn-row">
        <button class="btn btn-green" id="btn-retry">RETRY</button>
        <button class="btn" id="btn-new-mission">NEW MISSION</button>
        <button class="btn btn-orange" id="btn-export">EXPORT LOG</button>
        <button class="btn" id="btn-leaderboard">LEADERBOARD</button>
      </div>
    </div>
  </div>
  <div id="popup"></div>
  <div id="confirm-btns">
    <span class="cbtn cbtn-yes" id="cbtn-yes">&#10003;</span>
    <span class="cbtn cbtn-no" id="cbtn-no">&#10007;</span>
  </div>
  <div id="click-effects"></div>
  <div id="pause-menu">
    <h2 style="margin-bottom:30px;">PAUSED</h2>
    <button class="btn btn-green" id="btn-resume">RESUME</button>
    <button class="btn btn-red" id="btn-quit" style="margin-top:12px;">QUIT TO ARCADE</button>
  </div>
</div>
<script>
// ============================================================
// ROAD RECKONING: Pavement Strike Force
// QA Annotation Gamification for CYVL ARCADE
// ============================================================

const canvas = document.getElementById('scene');
const ctx = canvas.getContext('2d');
const W = 1024;
const H = 700;

// ============================================================
// COLOR PALETTE
// ============================================================
const COL = {
  bg: '#0a0a1a',
  road: '#3a3a4a',
  roadDark: '#2a2a38',
  lane: '#cccc44',
  laneDim: '#666622',
  cyan: '#00e5ff',
  green: '#00ff88',
  red: '#ff2244',
  orange: '#ff6600',
  gold: '#ffd700',
  white: '#ffffff',
  dimWhite: '#aaccee',
  purple: '#aa44ff',
  boxCorrect: '#00ff88',
  boxWrong: '#ff2244',
  boxMissing: '#ff660066',
  gridLine: '#1a1a2e',
};

// ============================================================
// OBJECT TYPES
// ============================================================
const OBJ_TYPES = ['POTHOLE', 'CRACK', 'SIGN', 'MANHOLE', 'MARKING', 'BARRIER'];
const OBJ_COLORS = {
  POTHOLE: '#443322',
  CRACK: '#555566',
  SIGN: '#2266aa',
  MANHOLE: '#555555',
  MARKING: '#cccc44',
  BARRIER: '#ff6600',
};

// ============================================================
// AUDIO SYSTEM (Web Audio API)
// ============================================================
let audioCtx = null;
function ensureAudio() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
}

function playSound(type) {
  ensureAudio();
  if (!audioCtx) return;
  const now = audioCtx.currentTime;
  const g = audioCtx.createGain();
  g.connect(audioCtx.destination);

  switch (type) {
    case 'click': {
      const o = audioCtx.createOscillator();
      o.connect(g);
      o.type = 'square';
      o.frequency.setValueAtTime(1200, now);
      o.frequency.exponentialRampToValueAtTime(600, now + 0.05);
      g.gain.setValueAtTime(0.08, now);
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
      o.start(now); o.stop(now + 0.05);
      break;
    }
    case 'correct': {
      const o = audioCtx.createOscillator();
      o.connect(g);
      o.type = 'sine';
      o.frequency.setValueAtTime(523, now);
      o.frequency.setValueAtTime(659, now + 0.08);
      o.frequency.setValueAtTime(784, now + 0.16);
      g.gain.setValueAtTime(0.12, now);
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
      o.start(now); o.stop(now + 0.25);
      break;
    }
    case 'wrong': {
      const o = audioCtx.createOscillator();
      o.connect(g);
      o.type = 'sawtooth';
      o.frequency.setValueAtTime(200, now);
      o.frequency.exponentialRampToValueAtTime(80, now + 0.3);
      g.gain.setValueAtTime(0.15, now);
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
      o.start(now); o.stop(now + 0.3);
      break;
    }
    case 'combo': {
      const o = audioCtx.createOscillator();
      o.connect(g);
      o.type = 'sine';
      o.frequency.setValueAtTime(880, now);
      o.frequency.setValueAtTime(1100, now + 0.05);
      o.frequency.setValueAtTime(1320, now + 0.1);
      o.frequency.setValueAtTime(1760, now + 0.15);
      g.gain.setValueAtTime(0.1, now);
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
      o.start(now); o.stop(now + 0.25);
      break;
    }
    case 'whoosh': {
      const bufferSize = audioCtx.sampleRate * 0.3;
      const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize);
      }
      const src = audioCtx.createBufferSource();
      src.buffer = buffer;
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'bandpass';
      filter.frequency.setValueAtTime(2000, now);
      filter.frequency.exponentialRampToValueAtTime(200, now + 0.3);
      filter.Q.value = 2;
      src.connect(filter);
      filter.connect(g);
      g.gain.setValueAtTime(0.1, now);
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
      src.start(now); src.stop(now + 0.3);
      break;
    }
    case 'victory': {
      const notes = [523, 659, 784, 1047, 784, 1047];
      notes.forEach((freq, i) => {
        const o = audioCtx.createOscillator();
        const gi = audioCtx.createGain();
        o.connect(gi);
        gi.connect(audioCtx.destination);
        o.type = 'sine';
        o.frequency.setValueAtTime(freq, now + i * 0.12);
        gi.gain.setValueAtTime(0.1, now + i * 0.12);
        gi.gain.exponentialRampToValueAtTime(0.001, now + i * 0.12 + 0.2);
        o.start(now + i * 0.12);
        o.stop(now + i * 0.12 + 0.2);
      });
      break;
    }
    case 'failure': {
      const o = audioCtx.createOscillator();
      o.connect(g);
      o.type = 'sawtooth';
      o.frequency.setValueAtTime(300, now);
      o.frequency.exponentialRampToValueAtTime(50, now + 1.0);
      g.gain.setValueAtTime(0.12, now);
      g.gain.exponentialRampToValueAtTime(0.001, now + 1.0);
      o.start(now); o.stop(now + 1.0);
      break;
    }
    case 'tick': {
      const o = audioCtx.createOscillator();
      o.connect(g);
      o.type = 'sine';
      o.frequency.setValueAtTime(1000, now);
      g.gain.setValueAtTime(0.06, now);
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
      o.start(now); o.stop(now + 0.05);
      break;
    }
  }
}

// ============================================================
// GAME STATE
// ============================================================
let gameState = 'TITLE'; // TITLE, BRIEFING, DEPLOY, GAMEPLAY, DEBRIEF
let currentMode = 'ELIMINATE';
let scenes = [];
let currentSceneIndex = 0;
let score = 0;
let combo = 1;
let streak = 0;
let maxCombo = 1;
let maxStreak = 0;
let totalCorrect = 0;
let totalWrong = 0;
let timer = 60;
let timerStart = 0;
let missionStartTime = 0;
let paused = false;
let pauseTimeAccum = 0;
let pauseStartedAt = 0;
let actionLog = [];
let lastTickSecond = -1;
let sceneStartTime = 0;
let sceneAdvanceReady = false;
let titleAnimTime = 0;
let briefingTyped = false;
let briefingCharIndex = 0;
let briefingFullText = '';
let countdownValue = 3;
let countdownTimer = 0;
let clickEffects = [];
let floatingTexts = [];
let confirmTarget = null;
let reclassifyTarget = null;
let streakTextTimer = 0;
let popupOpenTime = 0; // track when popup/confirm was opened to prevent same-click close

const TIMER_DURATIONS = {
  ELIMINATE: 60,
  DISCOVER: 60,
  RECLASSIFY: 90,
  CONFIRM: 120,
};

const TOTAL_SCENES = 15;

// ============================================================
// DOM REFS
// ============================================================
const overlay = document.getElementById('overlay');
const screenTitle = document.getElementById('screen-title');
const screenBriefing = document.getElementById('screen-briefing');
const screenDeploy = document.getElementById('screen-deploy');
const screenGameplay = document.getElementById('screen-gameplay');
const screenDebrief = document.getElementById('screen-debrief');
const hudTop = document.getElementById('hud-top');
const hudBottom = document.getElementById('hud-bottom');
const hudMode = document.getElementById('hud-mode');
const hudScene = document.getElementById('hud-scene');
const hudTimer = document.getElementById('hud-timer');
const hudScore = document.getElementById('hud-score');
const hudCombo = document.getElementById('hud-combo');
const hudStreak = document.getElementById('hud-streak');
const hudAccuracy = document.getElementById('hud-accuracy');
const popup = document.getElementById('popup');
const confirmBtns = document.getElementById('confirm-btns');
const pauseMenu = document.getElementById('pause-menu');
const briefingTextEl = document.getElementById('briefing-text');
const countdownEl = document.getElementById('countdown');
const deployModeEl = document.getElementById('deploy-mode');
const debriefGrade = document.getElementById('debrief-grade');
const debriefStats = document.getElementById('debrief-stats');

// ============================================================
// SCREEN MANAGEMENT
// ============================================================
function showScreen(name) {
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
  const el = document.getElementById('screen-' + name);
  if (el) el.classList.add('active');

  if (name === 'gameplay') {
    overlay.classList.add('hidden');
    hudTop.style.display = 'flex';
    hudBottom.style.display = 'flex';
  } else {
    overlay.classList.remove('hidden');
    hudTop.style.display = 'none';
    hudBottom.style.display = 'none';
  }
  popup.style.display = 'none';
  confirmBtns.style.display = 'none';
}

// ============================================================
// TITLE SCREEN
// ============================================================
function startTitle() {
  gameState = 'TITLE';
  showScreen('title');
  titleAnimTime = 0;
}

// ============================================================
// BRIEFING SCREEN
// ============================================================
const BRIEFING_TEXTS = {
  ELIMINATE: 'AGENT, our AI scanning pipeline has generated annotations across the target sector. However, analysis indicates HOSTILE ANNOTATIONS have infiltrated the dataset. Your mission: identify and ELIMINATE all incorrect bounding boxes. Trust your training. Misidentifying a valid annotation will cost us.',
  DISCOVER: 'AGENT, preliminary scans have missed critical infrastructure defects in the target zone. Objects exist on the road surface that have NO annotations. Your mission: DISCOVER these hidden targets and mark them for the database. Every missed defect is a liability.',
  RECLASSIFY: 'AGENT, our classifier has made labeling errors across the sector. Annotations exist but their TYPE LABELS are WRONG. Your mission: identify mislabeled annotations and RECLASSIFY them with the correct designation. Precision is paramount.',
  CONFIRM: 'AGENT, this is a FULL AUDIT mission. The sector contains a mix of correct annotations, incorrect annotations, and missing targets. Your mission: CONFIRM or DENY every annotation in the dataset. This is the ultimate test of your QA capabilities.',
};

function startBriefing() {
  gameState = 'BRIEFING';
  showScreen('briefing');
  briefingTyped = false;
  briefingCharIndex = 0;
  briefingFullText = 'Awaiting mission type selection...';
  briefingTextEl.textContent = '';
}

function updateBriefingText() {
  if (briefingTyped) return;
  briefingCharIndex += 2;
  if (briefingCharIndex >= briefingFullText.length) {
    briefingCharIndex = briefingFullText.length;
    briefingTyped = true;
  }
  briefingTextEl.textContent = briefingFullText.substring(0, briefingCharIndex) + (briefingTyped ? '' : '_');
}

// ============================================================
// DEPLOY (COUNTDOWN)
// ============================================================
function startDeploy() {
  gameState = 'DEPLOY';
  showScreen('deploy');
  deployModeEl.textContent = currentMode + ' MODE';
  countdownValue = 3;
  countdownTimer = performance.now();
  countdownEl.textContent = '3';
  playSound('whoosh');
}

function updateDeploy() {
  const elapsed = performance.now() - countdownTimer;
  const newVal = 3 - Math.floor(elapsed / 1000);
  if (newVal !== countdownValue && newVal >= 0) {
    countdownValue = newVal;
    countdownEl.textContent = countdownValue > 0 ? countdownValue : 'GO!';
    if (countdownValue > 0) playSound('tick');
    else playSound('whoosh');
  }
  if (elapsed >= 3500) {
    startGameplay();
  }
}

// ============================================================
// PROCEDURAL SCENE GENERATION
// ============================================================
function randInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

function randFloat(min, max) {
  return Math.random() * (max - min) + min;
}

function generateObject(roadBounds) {
  const type = OBJ_TYPES[randInt(0, OBJ_TYPES.length - 1)];
  let w, h;
  switch (type) {
    case 'POTHOLE':
      w = randInt(30, 60); h = randInt(25, 50); break;
    case 'CRACK':
      w = randInt(50, 100); h = randInt(10, 25); break;
    case 'SIGN':
      w = randInt(28, 48); h = randInt(40, 70); break;
    case 'MANHOLE':
      w = randInt(35, 50); h = randInt(35, 50); break;
    case 'MARKING':
      w = randInt(60, 120); h = randInt(8, 18); break;
    case 'BARRIER':
      w = randInt(50, 90); h = randInt(20, 35); break;
    default:
      w = 40; h = 40;
  }
  const x = randInt(roadBounds.x + 20, roadBounds.x + roadBounds.w - w - 20);
  const y = randInt(roadBounds.y + 20, roadBounds.y + roadBounds.h - h - 20);
  return { type, x, y, w, h, seed: Math.floor(Math.random() * 100000) };
}

function objectsOverlap(a, b, pad) {
  pad = pad || 10;
  return !(a.x + a.w + pad < b.x || b.x + b.w + pad < a.x ||
           a.y + a.h + pad < b.y || b.y + b.h + pad < a.y);
}

function generateScene(sceneIndex) {
  const roadY = 80;
  const roadH = H - 130;
  const laneCount = randInt(2, 4);
  const roadX = 100;
  const roadW = W - 200;
  const roadBounds = { x: roadX, y: roadY, w: roadW, h: roadH };
  const laneWidth = roadW / laneCount;

  // Generate real objects
  const objectCount = randInt(5, 9);
  const objects = [];
  let attempts = 0;
  while (objects.length < objectCount && attempts < 200) {
    const obj = generateObject(roadBounds);
    let overlap = false;
    for (const existing of objects) {
      if (objectsOverlap(obj, existing, 15)) { overlap = true; break; }
    }
    if (!overlap) objects.push(obj);
    attempts++;
  }

  // Build annotations based on mode
  const annotations = [];

  if (currentMode === 'ELIMINATE') {
    // All real objects get correct annotations
    for (const obj of objects) {
      annotations.push({
        x: obj.x - 5, y: obj.y - 5,
        w: obj.w + 10, h: obj.h + 10,
        label: obj.type,
        correct: true,
        objectRef: obj,
        eliminated: false,
      });
    }
    // Add 3-5 wrong annotations (no real object behind them)
    const wrongCount = randInt(3, 5);
    let wAttempts = 0;
    let wAdded = 0;
    while (wAdded < wrongCount && wAttempts < 100) {
      const fakeType = OBJ_TYPES[randInt(0, OBJ_TYPES.length - 1)];
      const fw = randInt(30, 80);
      const fh = randInt(25, 60);
      const fx = randInt(roadBounds.x + 10, roadBounds.x + roadBounds.w - fw - 10);
      const fy = randInt(roadBounds.y + 10, roadBounds.y + roadBounds.h - fh - 10);
      const fakeBox = { x: fx, y: fy, w: fw, h: fh };
      let tooClose = false;
      for (const obj of objects) {
        if (objectsOverlap(fakeBox, obj, 20)) { tooClose = true; break; }
      }
      for (const ann of annotations) {
        if (!ann.correct && objectsOverlap(fakeBox, ann, 10)) { tooClose = true; break; }
      }
      if (!tooClose) {
        annotations.push({
          x: fx, y: fy, w: fw, h: fh,
          label: fakeType,
          correct: false,
          objectRef: null,
          eliminated: false,
        });
        wAdded++;
      }
      wAttempts++;
    }
  } else if (currentMode === 'DISCOVER') {
    // Some objects annotated, some missing
    const missingCount = randInt(2, 4);
    const missingIndices = new Set();
    while (missingIndices.size < missingCount && missingIndices.size < objects.length) {
      missingIndices.add(randInt(0, objects.length - 1));
    }
    for (let i = 0; i < objects.length; i++) {
      const obj = objects[i];
      if (missingIndices.has(i)) {
        annotations.push({
          x: obj.x - 5, y: obj.y - 5,
          w: obj.w + 10, h: obj.h + 10,
          label: obj.type,
          correct: true,
          missing: true,
          discovered: false,
          objectRef: obj,
        });
      } else {
        annotations.push({
          x: obj.x - 5, y: obj.y - 5,
          w: obj.w + 10, h: obj.h + 10,
          label: obj.type,
          correct: true,
          missing: false,
          discovered: false,
          objectRef: obj,
        });
      }
    }
  } else if (currentMode === 'RECLASSIFY') {
    const wrongLabelCount = randInt(3, 5);
    const wrongIndices = new Set();
    while (wrongIndices.size < wrongLabelCount && wrongIndices.size < objects.length) {
      wrongIndices.add(randInt(0, objects.length - 1));
    }
    for (let i = 0; i < objects.length; i++) {
      const obj = objects[i];
      let label = obj.type;
      let correctLabel = obj.type;
      let isWrong = false;
      if (wrongIndices.has(i)) {
        const otherTypes = OBJ_TYPES.filter(t => t !== obj.type);
        label = otherTypes[randInt(0, otherTypes.length - 1)];
        isWrong = true;
      }
      annotations.push({
        x: obj.x - 5, y: obj.y - 5,
        w: obj.w + 10, h: obj.h + 10,
        label: label,
        correctLabel: correctLabel,
        wrongLabel: isWrong,
        reclassified: false,
        objectRef: obj,
      });
    }
  } else if (currentMode === 'CONFIRM') {
    // Mix: some correct, some wrong (bad box), some missing
    const wrongCount = randInt(2, 3);
    const missingCount = randInt(1, 3);
    const wrongIndices = new Set();
    const missingIndices = new Set();
    while (wrongIndices.size < wrongCount && wrongIndices.size < objects.length) {
      wrongIndices.add(randInt(0, objects.length - 1));
    }
    while (missingIndices.size < missingCount && missingIndices.size < objects.length) {
      const idx = randInt(0, objects.length - 1);
      if (!wrongIndices.has(idx)) missingIndices.add(idx);
    }
    for (let i = 0; i < objects.length; i++) {
      const obj = objects[i];
      if (missingIndices.has(i)) {
        // Missing annotation - object exists but no box (don't push annotation)
        continue;
      }
      const isWrong = wrongIndices.has(i);
      annotations.push({
        x: obj.x - 5, y: obj.y - 5,
        w: obj.w + 10, h: obj.h + 10,
        label: isWrong ? OBJ_TYPES.filter(t => t !== obj.type)[randInt(0, 4)] : obj.type,
        correctAnnotation: !isWrong,
        judged: false,
        judgment: null,
        objectRef: obj,
      });
    }
    // Add 1-2 totally fake boxes
    const fakeTarget = randInt(1, 2);
    let fakeAdded = 0;
    let fAttempts = 0;
    while (fakeAdded < fakeTarget && fAttempts < 50) {
      const fakeType = OBJ_TYPES[randInt(0, OBJ_TYPES.length - 1)];
      const fw = randInt(30, 70);
      const fh = randInt(25, 55);
      const fx = randInt(roadBounds.x + 10, roadBounds.x + roadBounds.w - fw - 10);
      const fy = randInt(roadBounds.y + 10, roadBounds.y + roadBounds.h - fh - 10);
      const fakeBox = { x: fx, y: fy, w: fw, h: fh };
      let tooClose = false;
      for (const obj of objects) {
        if (objectsOverlap(fakeBox, obj, 15)) { tooClose = true; break; }
      }
      if (!tooClose) {
        annotations.push({
          x: fx, y: fy, w: fw, h: fh,
          label: fakeType,
          correctAnnotation: false,
          judged: false,
          judgment: null,
          objectRef: null,
        });
        fakeAdded++;
      }
      fAttempts++;
    }
  }

  return {
    index: sceneIndex,
    road: roadBounds,
    laneCount,
    laneWidth,
    objects,
    annotations,
    bgSeed: Math.random() * 10000,
  };
}

function generateAllScenes() {
  scenes = [];
  for (let i = 0; i < TOTAL_SCENES; i++) {
    scenes.push(generateScene(i));
  }
}

// ============================================================
// DRAWING: ROAD SCENE
// ============================================================
function drawRoadScene(scene) {
  // Background
  ctx.fillStyle = COL.bg;
  ctx.fillRect(0, 0, W, H);

  // Grid
  ctx.strokeStyle = COL.gridLine;
  ctx.lineWidth = 0.5;
  for (let gx = 0; gx < W; gx += 40) {
    ctx.beginPath();
    ctx.moveTo(gx, 0);
    ctx.lineTo(gx, H);
    ctx.stroke();
  }
  for (let gy = 0; gy < H; gy += 40) {
    ctx.beginPath();
    ctx.moveTo(0, gy);
    ctx.lineTo(W, gy);
    ctx.stroke();
  }

  const road = scene.road;

  // Road shoulder
  ctx.fillStyle = '#222230';
  ctx.fillRect(road.x - 15, road.y - 10, road.w + 30, road.h + 20);

  // Road surface
  ctx.fillStyle = COL.road;
  ctx.fillRect(road.x, road.y, road.w, road.h);

  // Road texture (random specks using seed)
  const rng = mulberry32(Math.floor(scene.bgSeed));
  ctx.fillStyle = COL.roadDark;
  for (let i = 0; i < 300; i++) {
    const sx = road.x + rng() * road.w;
    const sy = road.y + rng() * road.h;
    const sw = 1 + rng() * 3;
    ctx.fillRect(sx, sy, sw, sw);
  }

  // Lane markings
  ctx.strokeStyle = COL.lane;
  ctx.lineWidth = 2;
  ctx.setLineDash([20, 15]);
  for (let lane = 1; lane < scene.laneCount; lane++) {
    const lx = road.x + lane * scene.laneWidth;
    ctx.beginPath();
    ctx.moveTo(lx, road.y + 10);
    ctx.lineTo(lx, road.y + road.h - 10);
    ctx.stroke();
  }
  ctx.setLineDash([]);

  // Edge lines (solid)
  ctx.strokeStyle = COL.laneDim;
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(road.x, road.y);
  ctx.lineTo(road.x, road.y + road.h);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(road.x + road.w, road.y);
  ctx.lineTo(road.x + road.w, road.y + road.h);
  ctx.stroke();

  // Draw objects
  for (const obj of scene.objects) {
    drawRoadObject(obj, scene);
  }
}

function mulberry32(a) {
  return function() {
    a |= 0; a = a + 0x6D2B79F5 | 0;
    let t = Math.imul(a ^ a >>> 15, 1 | a);
    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}

function drawRoadObject(obj, scene) {
  ctx.save();
  switch (obj.type) {
    case 'POTHOLE':
      ctx.fillStyle = '#1a1a22';
      ctx.beginPath();
      ctx.ellipse(obj.x + obj.w / 2, obj.y + obj.h / 2, obj.w / 2, obj.h / 2, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#333344';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.ellipse(obj.x + obj.w / 2, obj.y + obj.h / 2, obj.w / 2 - 3, obj.h / 2 - 3, 0, 0, Math.PI * 2);
      ctx.stroke();
      // Inner shadow
      ctx.fillStyle = '#0a0a12';
      ctx.beginPath();
      ctx.ellipse(obj.x + obj.w / 2 + 2, obj.y + obj.h / 2 + 2, obj.w / 3, obj.h / 3, 0, 0, Math.PI * 2);
      ctx.fill();
      break;
    case 'CRACK': {
      const crackRng = mulberry32(obj.seed || 42);
      ctx.strokeStyle = '#1a1a22';
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.moveTo(obj.x, obj.y + obj.h / 2);
      const segments = 5;
      for (let s = 1; s <= segments; s++) {
        const sx = obj.x + (obj.w / segments) * s;
        const sy = obj.y + obj.h / 2 + (crackRng() - 0.5) * obj.h;
        ctx.lineTo(sx, sy);
      }
      ctx.stroke();
      // Secondary crack line
      ctx.strokeStyle = '#222233';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(obj.x + obj.w * 0.3, obj.y + obj.h * 0.3);
      ctx.lineTo(obj.x + obj.w * 0.6, obj.y + obj.h * 0.7);
      ctx.stroke();
      break;
    }
    case 'SIGN':
      // Post
      ctx.fillStyle = '#666677';
      ctx.fillRect(obj.x + obj.w / 2 - 2, obj.y + obj.h * 0.6, 4, obj.h * 0.4);
      // Sign face
      ctx.fillStyle = OBJ_COLORS.SIGN;
      ctx.fillRect(obj.x, obj.y, obj.w, obj.h * 0.6);
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 1;
      ctx.strokeRect(obj.x + 3, obj.y + 3, obj.w - 6, obj.h * 0.6 - 6);
      break;
    case 'MANHOLE':
      ctx.fillStyle = '#444455';
      ctx.beginPath();
      ctx.ellipse(obj.x + obj.w / 2, obj.y + obj.h / 2, obj.w / 2, obj.h / 2, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#555566';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.ellipse(obj.x + obj.w / 2, obj.y + obj.h / 2, obj.w / 2 - 4, obj.h / 2 - 4, 0, 0, Math.PI * 2);
      ctx.stroke();
      // Cross pattern
      ctx.strokeStyle = '#3a3a4a';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(obj.x + obj.w * 0.2, obj.y + obj.h * 0.2);
      ctx.lineTo(obj.x + obj.w * 0.8, obj.y + obj.h * 0.8);
      ctx.moveTo(obj.x + obj.w * 0.8, obj.y + obj.h * 0.2);
      ctx.lineTo(obj.x + obj.w * 0.2, obj.y + obj.h * 0.8);
      ctx.stroke();
      break;
    case 'MARKING':
      ctx.fillStyle = '#cccc44';
      ctx.setLineDash([]);
      const markW = obj.w / 3;
      for (let m = 0; m < 3; m++) {
        ctx.fillRect(obj.x + m * (markW + 5), obj.y, markW - 5, obj.h);
      }
      break;
    case 'BARRIER':
      ctx.fillStyle = '#ff6600';
      ctx.fillRect(obj.x, obj.y, obj.w, obj.h);
      // Stripes
      ctx.fillStyle = '#ffffff';
      const stripeW = 10;
      for (let sx = obj.x; sx < obj.x + obj.w; sx += stripeW * 2) {
        ctx.fillRect(sx, obj.y, stripeW, obj.h);
      }
      break;
  }
  ctx.restore();
}

// ============================================================
// DRAWING: ANNOTATIONS
// ============================================================
function drawAnnotations(scene, time) {
  const anns = scene.annotations;
  const pulse = 0.6 + Math.sin(time * 5) * 0.4;

  for (const ann of anns) {
    if (currentMode === 'ELIMINATE') {
      if (ann.eliminated) continue;
      const isWrong = !ann.correct;
      const boxColor = isWrong ? COL.boxWrong : COL.boxCorrect;
      // Visible fill on ALL boxes so they're easy to see
      ctx.fillStyle = isWrong ? 'rgba(255,34,68,0.18)' : 'rgba(0,255,136,0.10)';
      ctx.fillRect(ann.x, ann.y, ann.w, ann.h);
      // Thick border
      ctx.strokeStyle = boxColor;
      ctx.lineWidth = isWrong ? 3 : 2;
      ctx.setLineDash([6, 4]);
      ctx.strokeRect(ann.x, ann.y, ann.w, ann.h);
      ctx.setLineDash([]);
      // Wrong boxes pulse/glow
      if (isWrong) {
        ctx.strokeStyle = `rgba(255,34,68,${pulse * 0.5})`;
        ctx.lineWidth = 5;
        ctx.strokeRect(ann.x - 2, ann.y - 2, ann.w + 4, ann.h + 4);
      }
      // Label
      drawAnnotationLabel(ann.label, ann.x, ann.y - 4, boxColor);
      // Corner brackets for clickable feel
      drawCornerBrackets(ann.x, ann.y, ann.w, ann.h, boxColor);
    } else if (currentMode === 'DISCOVER') {
      if (ann.missing && !ann.discovered) {
        // BRIGHT pulsing box for missing targets â€” easy to spot
        const p = 0.5 + Math.sin(time * 4) * 0.4;
        ctx.fillStyle = `rgba(255,102,0,${p * 0.25})`;
        ctx.fillRect(ann.x - 4, ann.y - 4, ann.w + 8, ann.h + 8);
        ctx.strokeStyle = `rgba(255,102,0,${p})`;
        ctx.lineWidth = 3;
        ctx.setLineDash([6, 4]);
        ctx.strokeRect(ann.x - 4, ann.y - 4, ann.w + 8, ann.h + 8);
        ctx.setLineDash([]);
        // Blinking "?" label
        if (Math.sin(time * 6) > -0.3) {
          drawAnnotationLabel('??? CLICK TO DISCOVER', ann.x - 4, ann.y - 8, COL.orange);
        }
        drawCornerBrackets(ann.x - 4, ann.y - 4, ann.w + 8, ann.h + 8, COL.orange);
      } else if (ann.missing && ann.discovered) {
        ctx.fillStyle = 'rgba(0,255,136,0.15)';
        ctx.fillRect(ann.x, ann.y, ann.w, ann.h);
        ctx.strokeStyle = COL.green;
        ctx.lineWidth = 3;
        ctx.setLineDash([6, 4]);
        ctx.strokeRect(ann.x, ann.y, ann.w, ann.h);
        ctx.setLineDash([]);
        drawAnnotationLabel(ann.label + ' [FOUND]', ann.x, ann.y - 4, COL.green);
      } else if (!ann.missing) {
        ctx.fillStyle = 'rgba(0,255,136,0.08)';
        ctx.fillRect(ann.x, ann.y, ann.w, ann.h);
        ctx.strokeStyle = COL.boxCorrect;
        ctx.lineWidth = 2;
        ctx.setLineDash([6, 4]);
        ctx.strokeRect(ann.x, ann.y, ann.w, ann.h);
        ctx.setLineDash([]);
        drawAnnotationLabel(ann.label, ann.x, ann.y - 4, COL.boxCorrect);
      }
    } else if (currentMode === 'RECLASSIFY') {
      if (ann.reclassified) {
        ctx.fillStyle = 'rgba(0,255,136,0.15)';
        ctx.fillRect(ann.x, ann.y, ann.w, ann.h);
        ctx.strokeStyle = COL.green;
        ctx.lineWidth = 3;
        ctx.setLineDash([6, 4]);
        ctx.strokeRect(ann.x, ann.y, ann.w, ann.h);
        ctx.setLineDash([]);
        drawAnnotationLabel(ann.correctLabel + ' [FIXED]', ann.x, ann.y - 4, COL.green);
      } else {
        const isWrong = ann.wrongLabel;
        const boxColor = isWrong ? '#ffaa00' : COL.boxCorrect;
        ctx.fillStyle = isWrong ? 'rgba(255,170,0,0.15)' : 'rgba(0,255,136,0.08)';
        ctx.fillRect(ann.x, ann.y, ann.w, ann.h);
        ctx.strokeStyle = boxColor;
        ctx.lineWidth = isWrong ? 3 : 2;
        ctx.setLineDash([6, 4]);
        ctx.strokeRect(ann.x, ann.y, ann.w, ann.h);
        ctx.setLineDash([]);
        drawAnnotationLabel(ann.label + (isWrong ? ' [WRONG?]' : ''), ann.x, ann.y - 4, boxColor);
        if (isWrong) {
          drawCornerBrackets(ann.x, ann.y, ann.w, ann.h, '#ffaa00');
        }
      }
    } else if (currentMode === 'CONFIRM') {
      if (ann.judged) {
        const col = ann.judgment === ann.correctAnnotation ? COL.green : COL.red;
        ctx.fillStyle = ann.judgment === ann.correctAnnotation ? 'rgba(0,255,136,0.15)' : 'rgba(255,34,68,0.15)';
        ctx.fillRect(ann.x, ann.y, ann.w, ann.h);
        ctx.strokeStyle = col;
        ctx.lineWidth = 3;
        ctx.setLineDash([]);
        ctx.strokeRect(ann.x, ann.y, ann.w, ann.h);
        const mark = ann.judgment ? '\u2713' : '\u2717';
        drawAnnotationLabel(ann.label + ' ' + mark, ann.x, ann.y - 4, col);
      } else {
        // Bright cyan fill + border for unjudged
        ctx.fillStyle = 'rgba(0,229,255,0.12)';
        ctx.fillRect(ann.x, ann.y, ann.w, ann.h);
        ctx.strokeStyle = COL.cyan;
        ctx.lineWidth = 3;
        ctx.setLineDash([6, 4]);
        ctx.strokeRect(ann.x, ann.y, ann.w, ann.h);
        ctx.setLineDash([]);
        drawAnnotationLabel(ann.label + ' [CLICK TO JUDGE]', ann.x, ann.y - 4, COL.cyan);
        drawCornerBrackets(ann.x, ann.y, ann.w, ann.h, COL.cyan);
      }
    }
  }
}

// Draw corner brackets on annotation boxes for a "targeting" feel
function drawCornerBrackets(x, y, w, h, color) {
  const len = Math.min(10, w / 4, h / 4);
  ctx.strokeStyle = color;
  ctx.lineWidth = 2;
  ctx.setLineDash([]);
  // Top-left
  ctx.beginPath();
  ctx.moveTo(x - 3, y - 3 + len); ctx.lineTo(x - 3, y - 3); ctx.lineTo(x - 3 + len, y - 3);
  ctx.stroke();
  // Top-right
  ctx.beginPath();
  ctx.moveTo(x + w + 3 - len, y - 3); ctx.lineTo(x + w + 3, y - 3); ctx.lineTo(x + w + 3, y - 3 + len);
  ctx.stroke();
  // Bottom-left
  ctx.beginPath();
  ctx.moveTo(x - 3, y + h + 3 - len); ctx.lineTo(x - 3, y + h + 3); ctx.lineTo(x - 3 + len, y + h + 3);
  ctx.stroke();
  // Bottom-right
  ctx.beginPath();
  ctx.moveTo(x + w + 3 - len, y + h + 3); ctx.lineTo(x + w + 3, y + h + 3); ctx.lineTo(x + w + 3, y + h + 3 - len);
  ctx.stroke();
}

function drawAnnotationLabel(text, x, y, color) {
  ctx.font = 'bold 10px Courier New';
  const tw = ctx.measureText(text).width;
  ctx.fillStyle = 'rgba(0,5,10,0.8)';
  ctx.fillRect(x, y - 12, tw + 8, 14);
  ctx.fillStyle = color;
  ctx.fillText(text, x + 4, y - 2);
}

// ============================================================
// CLICK EFFECTS
// ============================================================
function addClickEffect(x, y, correct) {
  clickEffects.push({
    x, y,
    radius: 5,
    maxRadius: 40,
    alpha: 1,
    color: correct ? COL.green : COL.red,
    time: 0,
  });
}

function addFloatingText(x, y, text, color) {
  floatingTexts.push({
    x, y, text, color,
    alpha: 1,
    vy: -2,
    time: 0,
  });
}

function updateEffects(dt) {
  for (let i = clickEffects.length - 1; i >= 0; i--) {
    const e = clickEffects[i];
    e.time += dt;
    e.radius = 5 + (e.maxRadius - 5) * (e.time / 0.4);
    e.alpha = 1 - e.time / 0.4;
    if (e.time >= 0.4) clickEffects.splice(i, 1);
  }
  for (let i = floatingTexts.length - 1; i >= 0; i--) {
    const ft = floatingTexts[i];
    ft.time += dt;
    ft.y += ft.vy;
    ft.alpha = 1 - ft.time / 1.2;
    if (ft.time >= 1.2) floatingTexts.splice(i, 1);
  }
  if (streakTextTimer > 0) streakTextTimer -= dt;
}

function drawEffects() {
  for (const e of clickEffects) {
    ctx.strokeStyle = e.color;
    ctx.lineWidth = 2;
    ctx.globalAlpha = Math.max(0, e.alpha);
    ctx.beginPath();
    ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
    ctx.stroke();
    // Inner flash
    ctx.fillStyle = e.color;
    ctx.globalAlpha = Math.max(0, e.alpha * 0.3);
    ctx.beginPath();
    ctx.arc(e.x, e.y, e.radius * 0.5, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  for (const ft of floatingTexts) {
    ctx.globalAlpha = Math.max(0, ft.alpha);
    ctx.font = 'bold 16px Courier New';
    ctx.fillStyle = ft.color;
    ctx.textAlign = 'center';
    ctx.fillText(ft.text, ft.x, ft.y);
  }
  ctx.globalAlpha = 1;
  ctx.textAlign = 'left';

  // Streak text
  if (streakTextTimer > 0 && streak >= 3) {
    const alpha = Math.min(1, streakTextTimer / 0.5);
    ctx.globalAlpha = alpha;
    ctx.font = 'bold 36px Courier New';
    ctx.fillStyle = combo >= 4 ? COL.red : combo >= 3 ? COL.gold : COL.green;
    ctx.textAlign = 'center';
    ctx.shadowColor = ctx.fillStyle;
    ctx.shadowBlur = 20;
    ctx.fillText('STREAK! x' + combo, W / 2, H / 2 - 40);
    ctx.shadowBlur = 0;
    ctx.globalAlpha = 1;
    ctx.textAlign = 'left';
  }
}

// ============================================================
// MODE INSTRUCTION BANNER
// ============================================================
const MODE_INSTRUCTIONS = {
  ELIMINATE: 'CLICK the RED boxes to eliminate bad annotations',
  DISCOVER: 'CLICK the ORANGE pulsing areas to discover missing annotations',
  RECLASSIFY: 'CLICK AMBER [WRONG?] labels, then pick the correct type',
  CONFIRM: 'CLICK each CYAN box, then mark it correct or incorrect',
};

function drawModeInstruction(time) {
  const text = MODE_INSTRUCTIONS[currentMode] || '';
  const alpha = 0.7 + Math.sin(time * 3) * 0.15;
  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.font = 'bold 13px Courier New';
  ctx.textAlign = 'center';
  // Background bar
  ctx.fillStyle = 'rgba(0,10,20,0.85)';
  const tw = ctx.measureText(text).width + 40;
  ctx.fillRect(W / 2 - tw / 2, 50, tw, 24);
  ctx.strokeStyle = COL.cyan + '44';
  ctx.lineWidth = 1;
  ctx.strokeRect(W / 2 - tw / 2, 50, tw, 24);
  // Text
  ctx.fillStyle = COL.cyan;
  ctx.fillText(text, W / 2, 66);
  ctx.restore();
  ctx.textAlign = 'left';
}

// ============================================================
// CROSSHAIR DRAWING
// ============================================================
let mouseX = W / 2, mouseY = H / 2;

function drawCrosshair() {
  if (gameState !== 'GAMEPLAY') return;
  const cx = mouseX;
  const cy = mouseY;
  ctx.strokeStyle = COL.cyan;
  ctx.lineWidth = 1;
  ctx.globalAlpha = 0.6;

  // Horizontal
  ctx.beginPath();
  ctx.moveTo(cx - 15, cy);
  ctx.lineTo(cx - 5, cy);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(cx + 5, cy);
  ctx.lineTo(cx + 15, cy);
  ctx.stroke();

  // Vertical
  ctx.beginPath();
  ctx.moveTo(cx, cy - 15);
  ctx.lineTo(cx, cy - 5);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(cx, cy + 5);
  ctx.lineTo(cx, cy + 15);
  ctx.stroke();

  // Center dot
  ctx.fillStyle = COL.cyan;
  ctx.beginPath();
  ctx.arc(cx, cy, 1.5, 0, Math.PI * 2);
  ctx.fill();

  ctx.globalAlpha = 1;
}

// ============================================================
// GAMEPLAY LOGIC
// ============================================================
function startGameplay() {
  gameState = 'GAMEPLAY';
  showScreen('gameplay');
  score = 0;
  combo = 1;
  streak = 0;
  maxCombo = 1;
  maxStreak = 0;
  totalCorrect = 0;
  totalWrong = 0;
  actionLog = [];
  currentSceneIndex = 0;
  timer = TIMER_DURATIONS[currentMode];
  lastTickSecond = -1;
  paused = false;
  pauseTimeAccum = 0;
  clickEffects = [];
  floatingTexts = [];
  confirmTarget = null;
  reclassifyTarget = null;
  streakTextTimer = 0;

  generateAllScenes();
  missionStartTime = performance.now();
  timerStart = performance.now();
  sceneStartTime = performance.now();
  updateHUD();
}

function getTimeElapsed() {
  if (paused) {
    return (pauseStartedAt - timerStart - pauseTimeAccum) / 1000;
  }
  return (performance.now() - timerStart - pauseTimeAccum) / 1000;
}

function getTimeRemaining() {
  const dur = TIMER_DURATIONS[currentMode];
  return Math.max(0, dur - getTimeElapsed());
}

function checkSceneComplete() {
  const scene = scenes[currentSceneIndex];
  const anns = scene.annotations;

  if (currentMode === 'ELIMINATE') {
    // All wrong annotations eliminated
    return anns.filter(a => !a.correct && !a.eliminated).length === 0;
  } else if (currentMode === 'DISCOVER') {
    return anns.filter(a => a.missing && !a.discovered).length === 0;
  } else if (currentMode === 'RECLASSIFY') {
    return anns.filter(a => a.wrongLabel && !a.reclassified).length === 0;
  } else if (currentMode === 'CONFIRM') {
    return anns.filter(a => !a.judged).length === 0;
  }
  return false;
}

function advanceScene() {
  currentSceneIndex++;
  if (currentSceneIndex >= TOTAL_SCENES) {
    endMission();
    return;
  }
  sceneStartTime = performance.now();
  sceneAdvanceReady = false;
  playSound('whoosh');
  popup.style.display = 'none';
  confirmBtns.style.display = 'none';
  confirmTarget = null;
  reclassifyTarget = null;
  updateHUD();
}

function endMission() {
  gameState = 'DEBRIEF';
  const totalActions = totalCorrect + totalWrong;
  const accuracy = totalActions > 0 ? (totalCorrect / totalActions * 100) : 0;

  popup.style.display = 'none';
  confirmBtns.style.display = 'none';

  let grade, gradeClass;
  if (accuracy >= 95) { grade = 'S'; gradeClass = 'grade-S'; }
  else if (accuracy >= 85) { grade = 'A'; gradeClass = 'grade-A'; }
  else if (accuracy >= 75) { grade = 'B'; gradeClass = 'grade-B'; }
  else if (accuracy >= 65) { grade = 'C'; gradeClass = 'grade-C'; }
  else if (accuracy >= 50) { grade = 'D'; gradeClass = 'grade-D'; }
  else { grade = 'F'; gradeClass = 'grade-F'; }

  debriefGrade.textContent = grade;
  debriefGrade.className = 'grade-display ' + gradeClass;

  const scenesCompleted = Math.min(currentSceneIndex + 1, TOTAL_SCENES);
  debriefStats.innerHTML = `
    <span class="stat-label">Mode:</span><span class="stat-value">${currentMode}</span>
    <span class="stat-label">Score:</span><span class="stat-value">${score}</span>
    <span class="stat-label">Accuracy:</span><span class="stat-value">${accuracy.toFixed(1)}%</span>
    <span class="stat-label">Scenes:</span><span class="stat-value">${scenesCompleted}/${TOTAL_SCENES}</span>
    <span class="stat-label">Correct:</span><span class="stat-value">${totalCorrect}</span>
    <span class="stat-label">Wrong:</span><span class="stat-value">${totalWrong}</span>
    <span class="stat-label">Max Combo:</span><span class="stat-value">x${maxCombo}</span>
    <span class="stat-label">Max Streak:</span><span class="stat-value">${maxStreak}</span>
  `;

  showScreen('debrief');
  if (accuracy >= 50) playSound('victory');
  else playSound('failure');
}

function recordAction(action, target, result, scoreAwarded) {
  const elapsed = (performance.now() - missionStartTime - pauseTimeAccum) / 1000;
  actionLog.push({
    scene: currentSceneIndex + 1,
    timestamp: parseFloat(elapsed.toFixed(1)),
    mode: currentMode,
    action: action,
    target: {
      type: target.label || target.type || 'UNKNOWN',
      x: Math.round(target.x),
      y: Math.round(target.y),
      correct: result === 'correct',
    },
    result: result,
    combo: combo,
    scoreAwarded: scoreAwarded,
  });
}

function handleCorrectAction() {
  streak++;
  if (streak > maxStreak) maxStreak = streak;
  const prevCombo = combo;
  combo = Math.min(4, 1 + Math.floor(streak / 3));
  if (combo > maxCombo) maxCombo = combo;
  if (combo > prevCombo) {
    playSound('combo');
    streakTextTimer = 1.5;
  } else {
    playSound('correct');
  }
  if (streak >= 3) {
    streakTextTimer = 1.5;
  }
  totalCorrect++;
}

function handleWrongAction() {
  streak = 0;
  combo = 1;
  totalWrong++;
  playSound('wrong');
}

function updateHUD() {
  hudMode.textContent = currentMode;
  hudScene.textContent = (currentSceneIndex + 1) + '/' + TOTAL_SCENES;
  hudScore.textContent = score;
  hudCombo.textContent = 'x' + combo;
  hudStreak.textContent = streak;
  const total = totalCorrect + totalWrong;
  const acc = total > 0 ? Math.round(totalCorrect / total * 100) : 100;
  hudAccuracy.textContent = acc + '%';

  // Combo glow
  hudCombo.className = 'hud-value combo-glow-' + combo;

  // Timer color
  const tr = getTimeRemaining();
  if (tr <= 10) {
    hudTimer.style.color = COL.red;
  } else if (tr <= 20) {
    hudTimer.style.color = COL.orange;
  } else {
    hudTimer.style.color = COL.cyan;
  }
  hudTimer.textContent = Math.ceil(tr);
}

// ============================================================
// CLICK HANDLING
// ============================================================
function getCanvasCoords(e) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = W / rect.width;
  const scaleY = H / rect.height;
  return {
    x: (e.clientX - rect.left) * scaleX,
    y: (e.clientY - rect.top) * scaleY,
  };
}

function isPointInBox(px, py, box) {
  return px >= box.x && px <= box.x + box.w && py >= box.y && py <= box.y + box.h;
}

function handleGameClick(x, y) {
  if (gameState !== 'GAMEPLAY' || paused) return;
  if (getTimeRemaining() <= 0) return;

  const scene = scenes[currentSceneIndex];

  playSound('click');
  addClickEffect(x, y, true);

  if (currentMode === 'ELIMINATE') {
    handleEliminateClick(scene, x, y);
  } else if (currentMode === 'DISCOVER') {
    handleDiscoverClick(scene, x, y);
  } else if (currentMode === 'RECLASSIFY') {
    handleReclassifyClick(scene, x, y);
  } else if (currentMode === 'CONFIRM') {
    handleConfirmClick(scene, x, y);
  }

  updateHUD();

  if (checkSceneComplete()) {
    sceneAdvanceReady = true;
    // Auto-advance after a short delay
    setTimeout(() => {
      if (gameState === 'GAMEPLAY' && sceneAdvanceReady) {
        advanceScene();
      }
    }, 800);
  }
}

function handleEliminateClick(scene, x, y) {
  // Check if clicked any annotation box
  for (const ann of scene.annotations) {
    if (ann.eliminated) continue;
    if (isPointInBox(x, y, ann)) {
      if (!ann.correct) {
        // Correct elimination
        ann.eliminated = true;
        const awarded = 100 * combo;
        score += awarded;
        handleCorrectAction();
        addClickEffect(x, y, true);
        addFloatingText(x, y - 20, '+' + awarded, COL.green);
        recordAction('eliminate', ann, 'correct', awarded);
      } else {
        // Wrong click on correct annotation
        const penalty = -50;
        score += penalty;
        handleWrongAction();
        addClickEffect(x, y, false);
        addFloatingText(x, y - 20, penalty.toString(), COL.red);
        recordAction('eliminate', ann, 'wrong', penalty);
      }
      return;
    }
  }
}

function handleDiscoverClick(scene, x, y) {
  // Check if clicked a missing annotation area
  for (const ann of scene.annotations) {
    if (ann.missing && !ann.discovered) {
      // Use a slightly larger hit area for missing objects
      const hitBox = { x: ann.x - 8, y: ann.y - 8, w: ann.w + 16, h: ann.h + 16 };
      if (isPointInBox(x, y, hitBox)) {
        ann.discovered = true;
        const awarded = 150 * combo;
        score += awarded;
        handleCorrectAction();
        addClickEffect(x, y, true);
        addFloatingText(x, y - 20, '+' + awarded, COL.green);
        recordAction('discover', ann, 'correct', awarded);
        return;
      }
    }
  }
  // False discovery: clicked where there is no missing object
  // But ignore clicks on existing (non-missing) annotations
  for (const ann of scene.annotations) {
    if (!ann.missing && isPointInBox(x, y, ann)) {
      return; // Clicked on existing annotation - ignore
    }
  }
  // Check if click is on the road
  if (isPointInBox(x, y, scene.road)) {
    const penalty = -25;
    score += penalty;
    handleWrongAction();
    addClickEffect(x, y, false);
    addFloatingText(x, y - 20, penalty.toString(), COL.red);
    recordAction('discover', { x, y, label: 'EMPTY' }, 'wrong', penalty);
  }
}

function handleReclassifyClick(scene, x, y) {
  // If popup is open, ignore scene clicks
  if (popup.style.display !== 'none') return;

  for (const ann of scene.annotations) {
    if (ann.reclassified) continue;
    if (isPointInBox(x, y, ann)) {
      if (ann.wrongLabel) {
        // Show reclassify popup
        reclassifyTarget = ann;
        showReclassifyPopup(ann, x, y);
      }
      // Clicking correct annotations does nothing in RECLASSIFY
      return;
    }
  }
}

function showReclassifyPopup(ann, x, y) {
  popup.innerHTML = '';
  const containerRect = document.getElementById('game-container').getBoundingClientRect();
  const canvasRect = canvas.getBoundingClientRect();
  const scaleX = canvasRect.width / W;
  const scaleY = canvasRect.height / H;

  const popX = x * scaleX + canvasRect.left - containerRect.left;
  const popY = y * scaleY + canvasRect.top - containerRect.top;

  popup.style.left = Math.min(popX, W - 150) + 'px';
  popup.style.top = Math.min(popY, H - 200) + 'px';
  popup.style.display = 'block';
  popupOpenTime = performance.now();

  const title = document.createElement('div');
  title.style.cssText = 'color:#ff6600;font-size:10px;margin-bottom:4px;';
  title.textContent = 'RECLASSIFY AS:';
  popup.appendChild(title);

  for (const t of OBJ_TYPES) {
    const btn = document.createElement('button');
    btn.className = 'popup-btn';
    btn.textContent = t;
    if (t === ann.label) {
      btn.style.color = '#ff660088';
      btn.style.borderColor = '#ff660044';
    }
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      handleReclassifyChoice(ann, t);
    });
    popup.appendChild(btn);
  }
}

function handleReclassifyChoice(ann, chosenType) {
  popup.style.display = 'none';
  reclassifyTarget = null;

  if (chosenType === ann.correctLabel) {
    // Correct reclassification
    ann.reclassified = true;
    ann.label = chosenType;
    const awarded = 200 * combo;
    score += awarded;
    handleCorrectAction();
    addClickEffect(ann.x + ann.w / 2, ann.y + ann.h / 2, true);
    addFloatingText(ann.x + ann.w / 2, ann.y - 10, '+' + awarded, COL.green);
    recordAction('reclassify', ann, 'correct', awarded);
  } else {
    // Wrong reclassification
    const penalty = -75;
    score += penalty;
    handleWrongAction();
    addClickEffect(ann.x + ann.w / 2, ann.y + ann.h / 2, false);
    addFloatingText(ann.x + ann.w / 2, ann.y - 10, penalty.toString(), COL.red);
    recordAction('reclassify', ann, 'wrong', penalty);
  }
  updateHUD();

  if (checkSceneComplete()) {
    sceneAdvanceReady = true;
    setTimeout(() => {
      if (gameState === 'GAMEPLAY' && sceneAdvanceReady) advanceScene();
    }, 800);
  }
}

function handleConfirmClick(scene, x, y) {
  // If confirm buttons are open, ignore further clicks
  if (confirmBtns.style.display !== 'none') return;

  for (const ann of scene.annotations) {
    if (ann.judged) continue;
    if (isPointInBox(x, y, ann)) {
      confirmTarget = ann;
      showConfirmButtons(ann, x, y);
      return;
    }
  }
}

function showConfirmButtons(ann, x, y) {
  const containerRect = document.getElementById('game-container').getBoundingClientRect();
  const canvasRect = canvas.getBoundingClientRect();
  const scaleX = canvasRect.width / W;
  const scaleY = canvasRect.height / H;

  const popX = x * scaleX + canvasRect.left - containerRect.left;
  const popY = y * scaleY + canvasRect.top - containerRect.top;

  confirmBtns.style.left = Math.min(popX - 45, W - 100) + 'px';
  confirmBtns.style.top = Math.max(popY - 50, 50) + 'px';
  confirmBtns.style.display = 'block';
  popupOpenTime = performance.now();
}

function handleConfirmJudgment(approve) {
  if (!confirmTarget) return;
  const ann = confirmTarget;
  ann.judged = true;
  ann.judgment = approve;
  confirmBtns.style.display = 'none';

  // Correct: approve a correct annotation OR reject an incorrect one
  const isCorrectJudgment = (approve === ann.correctAnnotation);

  if (isCorrectJudgment) {
    const awarded = 50 * combo;
    score += awarded;
    handleCorrectAction();
    addClickEffect(ann.x + ann.w / 2, ann.y + ann.h / 2, true);
    addFloatingText(ann.x + ann.w / 2, ann.y - 10, '+' + awarded, COL.green);
    recordAction('confirm', ann, 'correct', awarded);
  } else {
    const penalty = -100;
    score += penalty;
    handleWrongAction();
    addClickEffect(ann.x + ann.w / 2, ann.y + ann.h / 2, false);
    addFloatingText(ann.x + ann.w / 2, ann.y - 10, penalty.toString(), COL.red);
    recordAction('confirm', ann, 'wrong', penalty);
  }

  confirmTarget = null;
  updateHUD();

  if (checkSceneComplete()) {
    sceneAdvanceReady = true;
    setTimeout(() => {
      if (gameState === 'GAMEPLAY' && sceneAdvanceReady) advanceScene();
    }, 800);
  }
}

// ============================================================
// TITLE SCREEN RENDERING
// ============================================================
function drawTitle(time) {
  ctx.fillStyle = COL.bg;
  ctx.fillRect(0, 0, W, H);

  // Grid background
  ctx.strokeStyle = '#0d1a2a';
  ctx.lineWidth = 0.5;
  for (let gx = 0; gx < W; gx += 30) {
    ctx.beginPath();
    ctx.moveTo(gx, 0);
    ctx.lineTo(gx, H);
    ctx.stroke();
  }
  for (let gy = 0; gy < H; gy += 30) {
    ctx.beginPath();
    ctx.moveTo(0, gy);
    ctx.lineTo(W, gy);
    ctx.stroke();
  }

  // Animated road perspective
  const roadCenterX = W / 2;
  const horizonY = H * 0.35;
  const roadTopW = 60;
  const roadBottomW = 500;

  // Road fill
  ctx.fillStyle = '#2a2a38';
  ctx.beginPath();
  ctx.moveTo(roadCenterX - roadTopW, horizonY);
  ctx.lineTo(roadCenterX + roadTopW, horizonY);
  ctx.lineTo(roadCenterX + roadBottomW, H);
  ctx.lineTo(roadCenterX - roadBottomW, H);
  ctx.closePath();
  ctx.fill();

  // Lane lines
  ctx.strokeStyle = '#cccc44';
  ctx.lineWidth = 2;
  const dashOffset = (time * 100) % 40;
  ctx.setLineDash([15, 10]);
  ctx.lineDashOffset = -dashOffset;
  ctx.beginPath();
  ctx.moveTo(roadCenterX, horizonY);
  ctx.lineTo(roadCenterX, H);
  ctx.stroke();
  ctx.setLineDash([]);
  ctx.lineDashOffset = 0;

  // Edge lines
  ctx.strokeStyle = '#666622';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(roadCenterX - roadTopW, horizonY);
  ctx.lineTo(roadCenterX - roadBottomW, H);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(roadCenterX + roadTopW, horizonY);
  ctx.lineTo(roadCenterX + roadBottomW, H);
  ctx.stroke();

  // Scan lines effect on road
  for (let sy = horizonY; sy < H; sy += 20) {
    const t = (sy - horizonY) / (H - horizonY);
    const halfW = roadTopW + (roadBottomW - roadTopW) * t;
    ctx.strokeStyle = `rgba(0,229,255,${0.03 + Math.sin(time * 3 + sy * 0.1) * 0.02})`;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(roadCenterX - halfW, sy);
    ctx.lineTo(roadCenterX + halfW, sy);
    ctx.stroke();
  }

  // Floating annotation boxes on the road
  const boxCount = 5;
  for (let i = 0; i < boxCount; i++) {
    const bTime = (time * 0.5 + i * 0.4) % 2;
    const bT = bTime / 2;
    const bY = horizonY + bT * (H - horizonY);
    const halfW = roadTopW + (roadBottomW - roadTopW) * bT;
    const bSize = 10 + bT * 30;
    const bX = roadCenterX + Math.sin(i * 2.5) * halfW * 0.5 - bSize / 2;

    ctx.strokeStyle = i % 2 === 0 ? COL.green : COL.red;
    ctx.globalAlpha = 0.3 + bT * 0.4;
    ctx.lineWidth = 1.5;
    ctx.setLineDash([4, 3]);
    ctx.strokeRect(bX, bY - bSize / 2, bSize, bSize);
    ctx.setLineDash([]);
  }
  ctx.globalAlpha = 1;
}

// ============================================================
// DEPLOY SCREEN RENDERING
// ============================================================
function drawDeploy(time) {
  ctx.fillStyle = COL.bg;
  ctx.fillRect(0, 0, W, H);

  // Grid
  ctx.strokeStyle = '#0d1a2a';
  ctx.lineWidth = 0.5;
  for (let gx = 0; gx < W; gx += 40) {
    ctx.beginPath(); ctx.moveTo(gx, 0); ctx.lineTo(gx, H); ctx.stroke();
  }
  for (let gy = 0; gy < H; gy += 40) {
    ctx.beginPath(); ctx.moveTo(0, gy); ctx.lineTo(W, gy); ctx.stroke();
  }

  // Radar sweep
  const cx = W / 2, cy = H / 2;
  const sweepAngle = time * 2;
  ctx.strokeStyle = 'rgba(0,229,255,0.15)';
  ctx.lineWidth = 1;
  for (let r = 40; r < 300; r += 60) {
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.stroke();
  }
  // Sweep line
  ctx.strokeStyle = 'rgba(0,229,255,0.4)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(cx, cy);
  ctx.lineTo(cx + Math.cos(sweepAngle) * 280, cy + Math.sin(sweepAngle) * 280);
  ctx.stroke();

  // Sweep trail
  ctx.fillStyle = 'rgba(0,229,255,0.05)';
  ctx.beginPath();
  ctx.moveTo(cx, cy);
  ctx.arc(cx, cy, 280, sweepAngle - 0.5, sweepAngle, false);
  ctx.closePath();
  ctx.fill();
}

// ============================================================
// MAIN RENDER LOOP
// ============================================================
let lastFrameTime = performance.now();

function render() {
  const now = performance.now();
  const dt = Math.min((now - lastFrameTime) / 1000, 0.1);
  lastFrameTime = now;
  const time = now / 1000;

  switch (gameState) {
    case 'TITLE':
      drawTitle(time);
      break;

    case 'BRIEFING':
      drawTitle(time);
      if (!briefingTyped) updateBriefingText();
      break;

    case 'DEPLOY':
      drawDeploy(time);
      updateDeploy();
      break;

    case 'GAMEPLAY':
      if (!paused) {
        updateEffects(dt);
        const tr = getTimeRemaining();

        // Timer tick sound
        if (tr <= 10 && tr > 0) {
          const sec = Math.ceil(tr);
          if (sec !== lastTickSecond) {
            lastTickSecond = sec;
            playSound('tick');
          }
        }

        // Auto-advance scene after time (20s per scene)
        const sceneElapsed = (now - sceneStartTime) / 1000;
        if (sceneElapsed >= 20 && !sceneAdvanceReady) {
          if (!checkSceneComplete()) {
            sceneAdvanceReady = true;
            setTimeout(() => {
              if (gameState === 'GAMEPLAY' && sceneAdvanceReady) advanceScene();
            }, 2000);
          }
        }

        // Timer expired
        if (tr <= 0) {
          endMission();
          break;
        }

        updateHUD();
      }

      // Draw scene
      const scene = scenes[currentSceneIndex];
      if (scene) {
        drawRoadScene(scene);
        drawAnnotations(scene, time);
      }
      drawEffects();
      drawCrosshair();
      // Mode instruction banner
      drawModeInstruction(time);
      break;

    case 'DEBRIEF':
      drawTitle(time);
      break;
  }

  requestAnimationFrame(render);
}

// ============================================================
// EVENT LISTENERS
// ============================================================
const container = document.getElementById('game-container');

container.addEventListener('mousemove', (e) => {
  const coords = getCanvasCoords(e);
  mouseX = coords.x;
  mouseY = coords.y;
});

canvas.addEventListener('click', (e) => {
  ensureAudio();
  const coords = getCanvasCoords(e);

  if (gameState === 'TITLE') {
    playSound('click');
    startBriefing();
  } else if (gameState === 'GAMEPLAY') {
    handleGameClick(coords.x, coords.y);
  }
});

// Mode selection buttons
document.querySelectorAll('.mode-btn').forEach(btn => {
  btn.addEventListener('click', (e) => {
    ensureAudio();
    playSound('click');
    currentMode = btn.dataset.mode;
    briefingFullText = BRIEFING_TEXTS[currentMode];
    briefingCharIndex = 0;
    briefingTyped = false;
    // Delay then start deploy
    setTimeout(() => {
      startDeploy();
    }, 800);
  });

  btn.addEventListener('mouseenter', () => {
    const mode = btn.dataset.mode;
    if (!briefingTyped || briefingFullText !== BRIEFING_TEXTS[mode]) {
      briefingFullText = BRIEFING_TEXTS[mode];
      briefingCharIndex = 0;
      briefingTyped = false;
    }
  });
});

// Confirm buttons
document.getElementById('cbtn-yes').addEventListener('click', (e) => {
  e.stopPropagation();
  handleConfirmJudgment(true);
});

document.getElementById('cbtn-no').addEventListener('click', (e) => {
  e.stopPropagation();
  handleConfirmJudgment(false);
});

// Debrief buttons
document.getElementById('btn-retry').addEventListener('click', () => {
  ensureAudio();
  playSound('click');
  startDeploy();
});

document.getElementById('btn-new-mission').addEventListener('click', () => {
  ensureAudio();
  playSound('click');
  startBriefing();
});

document.getElementById('btn-export').addEventListener('click', () => {
  ensureAudio();
  playSound('click');
  exportLog();
});

document.getElementById('btn-leaderboard').addEventListener('click', () => {
  ensureAudio();
  playSound('click');
  if (typeof CyvlLeaderboard !== 'undefined') {
    CyvlLeaderboard.show('road-reckoning', score);
  } else {
    addFloatingText(W / 2, H / 2, 'Leaderboard unavailable', COL.orange);
  }
});

// Disable arcade-nav ESC redirect during gameplay
window.ARCADE_NAV_DISABLE_ESC = true;

// Pause
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    if (gameState === 'GAMEPLAY') {
      togglePause();
    } else if (paused) {
      togglePause();
    }
  }
  if (e.key === ' ' || e.code === 'Space') {
    if (gameState === 'GAMEPLAY' && sceneAdvanceReady && !paused) {
      e.preventDefault();
      advanceScene();
    }
    if (gameState === 'TITLE') {
      e.preventDefault();
      ensureAudio();
      playSound('click');
      startBriefing();
    }
  }
});

function togglePause() {
  if (!paused) {
    paused = true;
    pauseStartedAt = performance.now();
    pauseMenu.classList.add('active');
  } else {
    paused = false;
    pauseTimeAccum += performance.now() - pauseStartedAt;
    pauseMenu.classList.remove('active');
    popup.style.display = 'none';
    confirmBtns.style.display = 'none';
  }
}

document.getElementById('btn-resume').addEventListener('click', () => {
  ensureAudio();
  playSound('click');
  togglePause();
});

document.getElementById('btn-quit').addEventListener('click', () => {
  ensureAudio();
  playSound('click');
  paused = false;
  pauseMenu.classList.remove('active');
  startTitle();
});

// Click on popup background to close (ignore if popup just opened on this same click)
document.addEventListener('click', (e) => {
  if (performance.now() - popupOpenTime < 100) return;
  if (popup.style.display !== 'none' && !popup.contains(e.target)) {
    popup.style.display = 'none';
    reclassifyTarget = null;
  }
  if (confirmBtns.style.display !== 'none' && !confirmBtns.contains(e.target)) {
    confirmBtns.style.display = 'none';
    confirmTarget = null;
  }
});

// ============================================================
// EXPORT LOG
// ============================================================
function exportLog() {
  const data = {
    game: 'ROAD RECKONING: Pavement Strike Force',
    mode: currentMode,
    score: score,
    accuracy: totalCorrect + totalWrong > 0
      ? parseFloat((totalCorrect / (totalCorrect + totalWrong) * 100).toFixed(1))
      : 0,
    totalCorrect: totalCorrect,
    totalWrong: totalWrong,
    maxCombo: maxCombo,
    maxStreak: maxStreak,
    actions: actionLog,
  };

  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'road-reckoning-log-' + Date.now() + '.json';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

// ============================================================
// PRESS START CLICK
// ============================================================
document.getElementById('press-start').addEventListener('click', () => {
  ensureAudio();
  playSound('click');
  startBriefing();
});

// ============================================================
// START
// ============================================================
startTitle();
requestAnimationFrame(render);

</script>
</body>
</html>
