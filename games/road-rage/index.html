<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ROAD RAGE — Highway Havoc</title>
<script defer src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script defer src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
<script defer src="/shared/leaderboard.js"></script>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #0a0a1a;
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  font-family: 'Courier New', monospace;
  overflow: hidden;
}
canvas {
  display: block;
  image-rendering: pixelated;
  border: 1px solid #00e5ff33;
  box-shadow: 0 0 30px #00e5ff22, inset 0 0 30px #00e5ff08;
}
</style>
</head>
<body>
<script src="/shared/arcade-nav.js"></script>
<canvas id="game"></canvas>
<script>
// ============================================================
//  ROAD RAGE: HIGHWAY HAVOC
//  A CYVL Arcade Game — Top-Down Highway Survival Combat
// ============================================================

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const W = 800;
const H = 700;
canvas.width = W;
canvas.height = H;

// ============================================================
//  COLOR PALETTE
// ============================================================
const COL = {
  bg: '#0a0a1a',
  cyan: '#00e5ff',
  green: '#00ff88',
  orange: '#ff6600',
  red: '#ff2244',
  purple: '#aa44ff',
  yellow: '#ffee00',
  gold: '#ffd700',
  white: '#ffffff',
  darkCyan: '#005566',
  dimWhite: '#aaaacc',
};

// ============================================================
//  GAME STATE
// ============================================================
const STATE = { TITLE: 0, PLAYING: 1, GAME_OVER: 2 };
let state = STATE.TITLE;

// ============================================================
//  WEB AUDIO — SOUND ENGINE
// ============================================================
let audioCtx = null;
function ensureAudio() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
}

function playSound(type) {
  ensureAudio();
  const now = audioCtx.currentTime;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain);
  gain.connect(audioCtx.destination);

  switch (type) {
    case 'honk':
      osc.type = 'square';
      osc.frequency.setValueAtTime(320, now);
      osc.frequency.linearRampToValueAtTime(280, now + 0.15);
      gain.gain.setValueAtTime(0.15, now);
      gain.gain.linearRampToValueAtTime(0, now + 0.3);
      osc.start(now);
      osc.stop(now + 0.3);
      break;

    case 'enemyHonk':
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(400, now);
      osc.frequency.linearRampToValueAtTime(350, now + 0.1);
      gain.gain.setValueAtTime(0.08, now);
      gain.gain.linearRampToValueAtTime(0, now + 0.15);
      osc.start(now);
      osc.stop(now + 0.15);
      break;

    case 'crash': {
      const noise = audioCtx.createBufferSource();
      const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.3, audioCtx.sampleRate);
      const data = buf.getChannelData(0);
      for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * (1 - i / data.length);
      noise.buffer = buf;
      const ng = audioCtx.createGain();
      ng.gain.setValueAtTime(0.2, now);
      ng.gain.linearRampToValueAtTime(0, now + 0.3);
      noise.connect(ng);
      ng.connect(audioCtx.destination);
      noise.start(now);
      break;
    }

    case 'nearMiss':
      osc.type = 'sine';
      osc.frequency.setValueAtTime(600, now);
      osc.frequency.linearRampToValueAtTime(900, now + 0.1);
      gain.gain.setValueAtTime(0.1, now);
      gain.gain.linearRampToValueAtTime(0, now + 0.15);
      osc.start(now);
      osc.stop(now + 0.15);
      break;

    case 'pickup':
      osc.type = 'sine';
      osc.frequency.setValueAtTime(800, now);
      osc.frequency.linearRampToValueAtTime(1200, now + 0.08);
      osc.frequency.linearRampToValueAtTime(1600, now + 0.15);
      gain.gain.setValueAtTime(0.1, now);
      gain.gain.linearRampToValueAtTime(0, now + 0.2);
      osc.start(now);
      osc.stop(now + 0.2);
      break;

    case 'rageActivate': {
      const o1 = audioCtx.createOscillator();
      const g1 = audioCtx.createGain();
      o1.connect(g1); g1.connect(audioCtx.destination);
      o1.type = 'sawtooth';
      o1.frequency.setValueAtTime(100, now);
      o1.frequency.linearRampToValueAtTime(400, now + 0.3);
      o1.frequency.linearRampToValueAtTime(200, now + 0.6);
      g1.gain.setValueAtTime(0.15, now);
      g1.gain.linearRampToValueAtTime(0.2, now + 0.3);
      g1.gain.linearRampToValueAtTime(0, now + 0.7);
      o1.start(now); o1.stop(now + 0.7);

      const o2 = audioCtx.createOscillator();
      const g2 = audioCtx.createGain();
      o2.connect(g2); g2.connect(audioCtx.destination);
      o2.type = 'square';
      o2.frequency.setValueAtTime(150, now);
      o2.frequency.linearRampToValueAtTime(600, now + 0.4);
      g2.gain.setValueAtTime(0.1, now);
      g2.gain.linearRampToValueAtTime(0, now + 0.5);
      o2.start(now); o2.stop(now + 0.5);
      break;
    }

    case 'rageWreck': {
      const noise = audioCtx.createBufferSource();
      const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.2, audioCtx.sampleRate);
      const data = buf.getChannelData(0);
      for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * (1 - i / data.length);
      noise.buffer = buf;
      const ng = audioCtx.createGain();
      ng.gain.setValueAtTime(0.25, now);
      ng.gain.linearRampToValueAtTime(0, now + 0.2);
      noise.connect(ng); ng.connect(audioCtx.destination);
      noise.start(now);

      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(200, now);
      osc.frequency.linearRampToValueAtTime(80, now + 0.2);
      gain.gain.setValueAtTime(0.15, now);
      gain.gain.linearRampToValueAtTime(0, now + 0.25);
      osc.start(now); osc.stop(now + 0.25);
      break;
    }

    case 'comboUp':
      osc.type = 'sine';
      osc.frequency.setValueAtTime(500 + comboCount * 200, now);
      osc.frequency.linearRampToValueAtTime(700 + comboCount * 200, now + 0.1);
      gain.gain.setValueAtTime(0.08, now);
      gain.gain.linearRampToValueAtTime(0, now + 0.15);
      osc.start(now); osc.stop(now + 0.15);
      break;

    case 'gameOver': {
      const o1 = audioCtx.createOscillator();
      const g1 = audioCtx.createGain();
      o1.connect(g1); g1.connect(audioCtx.destination);
      o1.type = 'sawtooth';
      o1.frequency.setValueAtTime(400, now);
      o1.frequency.linearRampToValueAtTime(100, now + 0.8);
      g1.gain.setValueAtTime(0.15, now);
      g1.gain.linearRampToValueAtTime(0, now + 1.0);
      o1.start(now); o1.stop(now + 1.0);

      const noise = audioCtx.createBufferSource();
      const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.5, audioCtx.sampleRate);
      const data = buf.getChannelData(0);
      for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / data.length, 2);
      noise.buffer = buf;
      const ng = audioCtx.createGain();
      ng.gain.setValueAtTime(0.2, now);
      ng.gain.linearRampToValueAtTime(0, now + 0.5);
      noise.connect(ng); ng.connect(audioCtx.destination);
      noise.start(now);
      break;
    }

    case 'shieldHit':
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(1000, now);
      osc.frequency.linearRampToValueAtTime(500, now + 0.15);
      gain.gain.setValueAtTime(0.1, now);
      gain.gain.linearRampToValueAtTime(0, now + 0.2);
      osc.start(now); osc.stop(now + 0.2);
      break;

    default:
      osc.start(now); osc.stop(now + 0.01);
      break;
  }
}

// Engine drone (continuous)
let engineOsc = null;
let engineGain = null;
function startEngine() {
  ensureAudio();
  if (engineOsc) return;
  engineOsc = audioCtx.createOscillator();
  engineGain = audioCtx.createGain();
  engineOsc.type = 'sawtooth';
  engineOsc.frequency.setValueAtTime(60, audioCtx.currentTime);
  engineGain.gain.setValueAtTime(0, audioCtx.currentTime);
  engineOsc.connect(engineGain);
  engineGain.connect(audioCtx.destination);
  engineOsc.start();
}

function updateEngineSound(speed) {
  if (!engineOsc || !audioCtx) return;
  const t = audioCtx.currentTime;
  const freq = 50 + speed * 0.4;
  const vol = state === STATE.PLAYING ? 0.04 + speed * 0.0002 : 0;
  engineOsc.frequency.setTargetAtTime(freq, t, 0.05);
  engineGain.gain.setTargetAtTime(vol, t, 0.05);
}

// Rage rumble
let rageOsc = null;
let rageGainNode = null;
function startRageRumble() {
  ensureAudio();
  if (rageOsc) return;
  rageOsc = audioCtx.createOscillator();
  rageGainNode = audioCtx.createGain();
  rageOsc.type = 'sawtooth';
  rageOsc.frequency.setValueAtTime(40, audioCtx.currentTime);
  rageGainNode.gain.setValueAtTime(0.08, audioCtx.currentTime);
  rageOsc.connect(rageGainNode);
  rageGainNode.connect(audioCtx.destination);
  rageOsc.start();
}

function stopRageRumble() {
  if (rageOsc) {
    try { rageOsc.stop(); } catch(e) {}
    rageOsc = null;
    rageGainNode = null;
  }
}

// ============================================================
//  INPUT
// ============================================================
const keys = {};
window.addEventListener('keydown', function(e) {
  if (typeof CyvlLeaderboard !== 'undefined' && CyvlLeaderboard.isOpen()) return;

  keys[e.code] = true;

  if (state === STATE.TITLE && (e.code === 'Enter' || e.code === 'Space')) {
    e.preventDefault();
    startGame();
  }
  if (state === STATE.GAME_OVER && e.code === 'Enter') {
    e.preventDefault();
    if (gameOverTimer > 1.5) {
      state = STATE.TITLE;
    }
  }
  if (state === STATE.PLAYING) {
    if (e.code === 'Space') {
      e.preventDefault();
      honkHorn();
    }
    if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
      e.preventDefault();
      activateRage();
    }
  }
});

window.addEventListener('keyup', function(e) {
  keys[e.code] = false;
});

// ============================================================
//  ROAD GEOMETRY
// ============================================================
const ROAD_LEFT = 130;
const ROAD_RIGHT = 670;
const ROAD_W = ROAD_RIGHT - ROAD_LEFT;
const LANE_COUNT = 5;
const LANE_W = ROAD_W / LANE_COUNT;
const SHOULDER_W = 20;

function laneCenter(lane) {
  return ROAD_LEFT + LANE_W * lane + LANE_W / 2;
}

// ============================================================
//  PLAYER
// ============================================================
let player = {};
const PLAYER_W = 34;
const PLAYER_H = 56;

function resetPlayer() {
  player = {
    x: W / 2,
    y: H - 120,
    w: PLAYER_W,
    h: PLAYER_H,
    vx: 0,
    vy: 0,
    speed: 120,
    health: 5,
    maxHealth: 5,
    invincibleTimer: 0,
    shielded: false,
    speedBoostTimer: 0,
    lidarAngle: 0,
    honkCooldown: 0,
  };
}

// ============================================================
//  GAME VARIABLES
// ============================================================
let score = 0;
let distance = 0;
let scrollSpeed = 200;
let baseScrollSpeed = 200;
let roadOffset = 0;
let displaySpeed = 0;

// Rage system
let rageMeter = 0;
let rageMode = false;
let rageTimer = 0;
const RAGE_DURATION = 5;
let rageActivations = 0;

// Near-miss combo
let comboCount = 0;
let comboTimer = 0;
const COMBO_TIMEOUT = 3.0;
let bestCombo = 0;

// Traffic
let cars = [];
let carSpawnTimer = 0;
let carsSpawned = 0;
let carsDodged = 0;
let carsWrecked = 0;

// Collectibles
let collectibles = [];
let collectibleTimer = 0;

// Particles
let particles = [];

// Floating text
let floatTexts = [];

// Roadside objects
let roadsideObjects = [];
let roadsideTimer = 0;

// Tire marks
let tireMarks = [];

// Screen effects
let screenShake = 0;
let screenFlashR = 0;
let screenFlashG = 0;
let nightMode = false;
let nightAlpha = 0;

// Game over
let gameOverTimer = 0;
let leaderboardShown = false;

// Title animation
let titleTime = 0;
let titleCars = [];

// ============================================================
//  PARTICLE SYSTEM
// ============================================================
function spawnParticles(x, y, count, color, speedMin, speedMax, lifeMin, lifeMax, sizeMin, sizeMax) {
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const spd = speedMin + Math.random() * (speedMax - speedMin);
    particles.push({
      x: x,
      y: y,
      vx: Math.cos(angle) * spd,
      vy: Math.sin(angle) * spd,
      life: lifeMin + Math.random() * (lifeMax - lifeMin),
      maxLife: lifeMin + Math.random() * (lifeMax - lifeMin),
      size: sizeMin + Math.random() * (sizeMax - sizeMin),
      color: color,
    });
  }
}

function spawnExplosion(x, y) {
  spawnParticles(x, y, 20, COL.orange, 50, 200, 0.3, 0.7, 2, 6);
  spawnParticles(x, y, 15, COL.red, 30, 150, 0.2, 0.5, 3, 8);
  spawnParticles(x, y, 10, COL.yellow, 80, 250, 0.1, 0.4, 1, 4);
}

function spawnSparks(x, y) {
  spawnParticles(x, y, 8, COL.yellow, 40, 120, 0.1, 0.3, 1, 3);
  spawnParticles(x, y, 5, COL.white, 20, 80, 0.1, 0.2, 1, 2);
}

// ============================================================
//  FLOATING TEXT
// ============================================================
function addFloatText(x, y, text, color, size, duration) {
  floatTexts.push({
    x: x,
    y: y,
    text: text,
    color: color,
    size: size || 18,
    life: duration || 1.0,
    maxLife: duration || 1.0,
  });
}

// ============================================================
//  ENEMY CAR TYPES
// ============================================================
const CAR_TYPES = {
  TAILGATER: 0,
  LANE_CUTTER: 1,
  BRAKE_CHECKER: 2,
  SPEED_DEMON: 3,
  ROAD_HOG: 4,
  WRONG_WAY: 5,
  NORMAL: 6,
};

function createCar(type, lane) {
  const base = {
    x: laneCenter(lane),
    y: -60,
    vx: 0,
    vy: 0,
    lane: lane,
    type: type,
    alive: true,
    nearMissed: false,
    honking: false,
    honkTimer: 0,
    flashTimer: 0,
    behaviorTimer: 0,
    behaviorPhase: 0,
    spinAngle: 0,
    flyingOff: false,
    flyVx: 0,
    flyVy: 0,
    flySpin: 0,
  };

  switch (type) {
    case CAR_TYPES.TAILGATER:
      return { ...base, w: 28, h: 48, color: '#cc2233', speed: scrollSpeed * 0.8, label: 'TAILGATER' };
    case CAR_TYPES.LANE_CUTTER:
      return { ...base, w: 28, h: 44, color: '#ddcc22', speed: scrollSpeed * 0.9, label: 'LANE CUTTER' };
    case CAR_TYPES.BRAKE_CHECKER:
      return { ...base, w: 30, h: 50, color: '#dd6622', speed: scrollSpeed * 1.1, label: 'BRAKE CHECKER', y: -100 };
    case CAR_TYPES.SPEED_DEMON:
      return { ...base, w: 26, h: 46, color: '#2266ee', speed: scrollSpeed * 1.8, label: 'SPEED DEMON' };
    case CAR_TYPES.ROAD_HOG:
      return { ...base, w: 44, h: 58, color: '#339944', speed: scrollSpeed * 0.5, label: 'ROAD HOG' };
    case CAR_TYPES.WRONG_WAY:
      return { ...base, w: 28, h: 48, color: '#9944cc', speed: scrollSpeed * 0.6, y: -60, label: 'WRONG WAY' };
    default:
      return { ...base, w: 28, h: 46, color: '#777788', speed: scrollSpeed * 0.7, label: 'NORMAL' };
  }
}

// ============================================================
//  CAR BEHAVIOR AI
// ============================================================
function updateCarBehavior(car, dt) {
  car.honkTimer -= dt;
  car.flashTimer -= dt;

  if (car.flyingOff) {
    car.x += car.flyVx * dt;
    car.y += car.flyVy * dt;
    car.spinAngle += car.flySpin * dt;
    return;
  }

  switch (car.type) {
    case CAR_TYPES.TAILGATER: {
      // Move down relative to scroll, then lock behind player and accelerate
      const relSpeed = scrollSpeed - car.speed;
      car.y += relSpeed * dt;

      // If below player, accelerate toward player
      if (car.y > player.y + 30) {
        // Try to get behind player
        const dx = player.x - car.x;
        car.vx = dx * 1.5;
        car.x += car.vx * dt;
        car.vy = -120;
        car.y += car.vy * dt;
        // Flash headlights
        car.flashTimer = 0.3;
        car.behaviorTimer += dt;
        if (car.behaviorTimer > 1.5 && car.honkTimer <= 0) {
          car.honkTimer = 2;
          playSound('enemyHonk');
          addRage(3);
        }
      } else {
        // Approaching from behind
        car.y += 80 * dt;
      }
      break;
    }

    case CAR_TYPES.LANE_CUTTER: {
      const relSpeed = scrollSpeed - car.speed;
      car.y += relSpeed * dt;

      car.behaviorTimer += dt;
      if (car.behaviorPhase === 0) {
        // Drive normally until near player vertically
        if (Math.abs(car.y - player.y) < 100 && car.behaviorTimer > 0.5) {
          car.behaviorPhase = 1;
          car.behaviorTimer = 0;
          // Swerve toward player lane
          car.vx = (player.x > car.x) ? 200 : -200;
          if (car.honkTimer <= 0) {
            playSound('enemyHonk');
            car.honkTimer = 3;
          }
          addRage(10);
          addFloatText(car.x, car.y - 30, 'CUT OFF!', COL.yellow, 14, 0.8);
        }
      } else {
        // Swerving
        car.x += car.vx * dt;
        car.vx *= 0.97;
        if (Math.abs(car.vx) < 10) car.vx = 0;
      }
      break;
    }

    case CAR_TYPES.BRAKE_CHECKER: {
      const relSpeed = scrollSpeed - car.speed;
      car.y += relSpeed * dt;

      car.behaviorTimer += dt;
      if (car.behaviorPhase === 0) {
        // Drive ahead
        if (car.y > player.y - 150 && car.y < player.y - 40 && Math.abs(car.x - player.x) < LANE_W) {
          car.behaviorPhase = 1;
          car.behaviorTimer = 0;
          car.speed = scrollSpeed * 2.5; // Slam brakes (comes at player fast)
        }
      } else if (car.behaviorPhase === 1) {
        // Braking - car decelerating so relative speed increases
        const brakeRel = scrollSpeed - car.speed;
        car.y += brakeRel * dt * 0.5;
        car.speed *= 0.98;
        if (car.behaviorTimer > 1.5) car.behaviorPhase = 2;
      }
      break;
    }

    case CAR_TYPES.SPEED_DEMON: {
      const relSpeed = scrollSpeed - car.speed;
      car.y += relSpeed * dt;

      // Weave through traffic
      car.behaviorTimer += dt;
      if (car.behaviorTimer > 0.4) {
        car.behaviorTimer = 0;
        car.vx = (Math.random() - 0.5) * 300;
      }
      car.x += car.vx * dt;
      car.vx *= 0.95;

      // Clamp to road
      car.x = Math.max(ROAD_LEFT + car.w / 2 + 5, Math.min(ROAD_RIGHT - car.w / 2 - 5, car.x));
      break;
    }

    case CAR_TYPES.ROAD_HOG: {
      const relSpeed = scrollSpeed - car.speed;
      car.y += relSpeed * dt;

      // Drift slowly between lanes
      car.behaviorTimer += dt;
      if (car.behaviorPhase === 0) {
        car.vx = 30;
        if (car.x > ROAD_RIGHT - car.w) car.behaviorPhase = 1;
      } else {
        car.vx = -30;
        if (car.x < ROAD_LEFT + car.w) car.behaviorPhase = 0;
      }
      car.x += car.vx * dt;
      break;
    }

    case CAR_TYPES.WRONG_WAY: {
      // Coming from top, driving DOWN toward player
      car.y += (scrollSpeed + car.speed) * dt;
      // Slight weave
      car.behaviorTimer += dt;
      car.x += Math.sin(car.behaviorTimer * 3) * 20 * dt;
      if (car.flashTimer <= 0) car.flashTimer = 0.5;
      break;
    }

    default: {
      // Normal traffic
      const relSpeed = scrollSpeed - car.speed;
      car.y += relSpeed * dt;
      break;
    }
  }
}

// ============================================================
//  COLLISION DETECTION
// ============================================================
function boxCollide(a, b) {
  return (
    a.x - a.w / 2 < b.x + b.w / 2 &&
    a.x + a.w / 2 > b.x - b.w / 2 &&
    a.y - a.h / 2 < b.y + b.h / 2 &&
    a.y + a.h / 2 > b.y - b.h / 2
  );
}

function nearMissCheck(car) {
  if (car.nearMissed || car.flyingOff) return;
  const dx = Math.abs(player.x - car.x) - (player.w + car.w) / 2;
  const dy = Math.abs(player.y - car.y) - (player.h + car.h) / 2;
  const nearDist = 15;

  if (dx < nearDist && dx > -5 && dy < nearDist) {
    car.nearMissed = true;
    triggerNearMiss(car);
  }
}

function triggerNearMiss(car) {
  comboCount++;
  comboTimer = COMBO_TIMEOUT;
  if (comboCount > bestCombo) bestCombo = comboCount;
  carsDodged++;

  let label, pts;
  if (comboCount >= 5) { label = 'GODLIKE!'; pts = 1000; }
  else if (comboCount === 4) { label = 'LEGENDARY!'; pts = 500; }
  else if (comboCount === 3) { label = 'INSANE!'; pts = 200; }
  else if (comboCount === 2) { label = 'RISKY!'; pts = 100; }
  else { label = 'CLOSE!'; pts = 50; }

  score += pts;
  addRage(5);
  addFloatText(player.x, player.y - 40, label + ' +' + pts, COL.gold, comboCount >= 3 ? 22 : 16, 1.2);
  spawnParticles(player.x, player.y, 5, COL.gold, 30, 80, 0.2, 0.4, 1, 3);
  playSound('nearMiss');
  if (comboCount > 1) playSound('comboUp');
  screenFlashG = 0.15;
}

// ============================================================
//  RAGE SYSTEM
// ============================================================
function addRage(amount) {
  if (rageMode) return;
  rageMeter = Math.min(100, rageMeter + amount);
}

function activateRage() {
  if (rageMeter < 100 || rageMode) return;
  rageMode = true;
  rageTimer = RAGE_DURATION;
  rageActivations++;
  player.invincibleTimer = RAGE_DURATION + 0.5;
  playSound('rageActivate');
  startRageRumble();
  screenShake = 0.5;
  addFloatText(W / 2, H / 2 - 50, 'RAGE MODE!', COL.red, 36, 1.5);
  spawnParticles(player.x, player.y, 30, COL.red, 50, 200, 0.3, 0.8, 2, 6);
  spawnParticles(player.x, player.y, 20, COL.orange, 40, 150, 0.2, 0.6, 2, 5);
}

function rageRamCar(car) {
  car.flyingOff = true;
  const dx = car.x - player.x;
  const dy = car.y - player.y;
  const dist = Math.max(1, Math.sqrt(dx * dx + dy * dy));
  car.flyVx = (dx / dist) * 600 + (Math.random() - 0.5) * 200;
  car.flyVy = (dy / dist) * 600 + (Math.random() - 0.5) * 200;
  car.flySpin = (Math.random() - 0.5) * 20;
  carsWrecked++;

  score += 300;
  spawnExplosion(car.x, car.y);
  screenShake = 0.3;
  playSound('rageWreck');

  const words = ['WRECKED!', 'DEMOLISHED!', 'OBLITERATED!', 'DESTROYED!', 'ANNIHILATED!'];
  addFloatText(car.x, car.y - 30, words[Math.floor(Math.random() * words.length)] + ' +300', COL.red, 20, 1.0);
}

// ============================================================
//  HONK SYSTEM
// ============================================================
function honkHorn() {
  if (player.honkCooldown > 0) return;
  player.honkCooldown = 3;
  playSound('honk');
  addFloatText(player.x, player.y - 40, 'HONK!', COL.white, 18, 0.6);

  // Scare tailgaters behind player
  for (let i = 0; i < cars.length; i++) {
    const c = cars[i];
    if (c.type === CAR_TYPES.TAILGATER && !c.flyingOff) {
      const dy = c.y - player.y;
      if (dy > 0 && dy < 120 && Math.abs(c.x - player.x) < LANE_W) {
        c.speed = scrollSpeed * 0.3; // Scared, slows down
        c.behaviorPhase = 99; // Stop aggressive behavior
        addFloatText(c.x, c.y - 20, 'SCARED!', COL.green, 12, 0.6);
      }
    }
  }
}

// ============================================================
//  SPAWN SYSTEMS
// ============================================================
function getSpawnRate() {
  if (distance < 500) return 1.8;
  if (distance < 1500) return 1.2;
  if (distance < 3000) return 0.8;
  if (distance < 5000) return 0.5;
  return 0.35;
}

function getAvailableTypes() {
  const types = [CAR_TYPES.NORMAL, CAR_TYPES.TAILGATER];
  if (distance > 300) types.push(CAR_TYPES.LANE_CUTTER);
  if (distance > 700) types.push(CAR_TYPES.BRAKE_CHECKER);
  if (distance > 1500) types.push(CAR_TYPES.SPEED_DEMON);
  if (distance > 2000) types.push(CAR_TYPES.ROAD_HOG);
  if (distance > 3000) types.push(CAR_TYPES.WRONG_WAY);
  return types;
}

function spawnCar() {
  const types = getAvailableTypes();
  const type = types[Math.floor(Math.random() * types.length)];
  const lane = Math.floor(Math.random() * LANE_COUNT);

  // Avoid spawning on top of player
  const lc = laneCenter(lane);
  if (Math.abs(lc - player.x) < LANE_W && type !== CAR_TYPES.WRONG_WAY) {
    // Try a different lane
    const alt = (lane + 2) % LANE_COUNT;
    const car = createCar(type, alt);
    cars.push(car);
  } else {
    cars.push(createCar(type, lane));
  }
  carsSpawned++;
}

function spawnCollectible() {
  const lane = Math.floor(Math.random() * LANE_COUNT);
  const types = ['data', 'coffee', 'hardhat', 'wrench'];
  const weights = [60, 20, 12, 8];
  let roll = Math.random() * 100;
  let picked = 'data';
  for (let i = 0; i < types.length; i++) {
    roll -= weights[i];
    if (roll <= 0) { picked = types[i]; break; }
  }

  collectibles.push({
    x: laneCenter(lane),
    y: -30,
    type: picked,
    size: 16,
    bobTimer: Math.random() * Math.PI * 2,
  });
}

function spawnRoadsideObject() {
  const side = Math.random() < 0.5 ? 'left' : 'right';
  const types = ['tree', 'sign', 'lamppost', 'barrier'];
  const type = types[Math.floor(Math.random() * types.length)];
  roadsideObjects.push({
    x: side === 'left' ? ROAD_LEFT - 35 - Math.random() * 30 : ROAD_RIGHT + 35 + Math.random() * 30,
    y: -40,
    type: type,
    side: side,
  });
}

// ============================================================
//  START / RESET GAME
// ============================================================
function startGame() {
  ensureAudio();
  startEngine();
  state = STATE.PLAYING;
  score = 0;
  distance = 0;
  scrollSpeed = 200;
  baseScrollSpeed = 200;
  roadOffset = 0;
  rageMeter = 0;
  rageMode = false;
  rageTimer = 0;
  rageActivations = 0;
  comboCount = 0;
  comboTimer = 0;
  bestCombo = 0;
  cars = [];
  collectibles = [];
  particles = [];
  floatTexts = [];
  roadsideObjects = [];
  tireMarks = [];
  carSpawnTimer = 0;
  collectibleTimer = 0;
  roadsideTimer = 0;
  carsSpawned = 0;
  carsDodged = 0;
  carsWrecked = 0;
  screenShake = 0;
  screenFlashR = 0;
  screenFlashG = 0;
  nightAlpha = 0;
  gameOverTimer = 0;
  leaderboardShown = false;
  displaySpeed = 60;
  resetPlayer();
}

// ============================================================
//  UPDATE — MAIN GAME LOGIC
// ============================================================
function update(dt) {
  if (state === STATE.TITLE) {
    updateTitle(dt);
    return;
  }
  if (state === STATE.GAME_OVER) {
    updateGameOver(dt);
    return;
  }

  // -- Player movement --
  const moveSpeed = player.speedBoostTimer > 0 ? 350 : 260;
  let dx = 0, dy = 0;
  if (keys['ArrowLeft'] || keys['KeyA']) dx = -1;
  if (keys['ArrowRight'] || keys['KeyD']) dx = 1;
  if (keys['ArrowUp'] || keys['KeyW']) dy = -1;
  if (keys['ArrowDown'] || keys['KeyS']) dy = 1;

  // Normalize diagonal
  if (dx !== 0 && dy !== 0) {
    dx *= 0.707;
    dy *= 0.707;
  }

  player.x += dx * moveSpeed * dt;
  player.y += dy * moveSpeed * dt;

  // Clamp player to road
  player.x = Math.max(ROAD_LEFT + player.w / 2 + 3, Math.min(ROAD_RIGHT - player.w / 2 - 3, player.x));
  player.y = Math.max(player.h / 2 + 10, Math.min(H - player.h / 2 - 10, player.y));

  // Timers
  player.invincibleTimer -= dt;
  player.speedBoostTimer -= dt;
  player.honkCooldown -= dt;
  player.lidarAngle += dt * 4;

  // Scroll speed increases with distance
  baseScrollSpeed = 200 + distance * 0.02;
  if (player.speedBoostTimer > 0) baseScrollSpeed *= 1.4;
  scrollSpeed = baseScrollSpeed;
  if (dy < 0) scrollSpeed *= 1.2; // Moving up speeds up scroll
  if (dy > 0) scrollSpeed *= 0.7; // Moving down slows scroll

  // Distance & speed display
  distance += scrollSpeed * dt * 0.01; // Convert to meters roughly
  displaySpeed = 40 + scrollSpeed * 0.25;
  if (player.speedBoostTimer > 0) displaySpeed *= 1.3;

  roadOffset += scrollSpeed * dt;

  // Night mode
  if (distance > 2500) {
    nightAlpha = Math.min(0.45, (distance - 2500) / 2000);
    nightMode = true;
  } else {
    nightAlpha = 0;
    nightMode = false;
  }

  // Combo timer
  if (comboTimer > 0) {
    comboTimer -= dt;
    if (comboTimer <= 0) {
      comboCount = 0;
    }
  }

  // Rage mode
  if (rageMode) {
    rageTimer -= dt;
    // Fire particles around van
    if (Math.random() < 0.5) {
      spawnParticles(
        player.x + (Math.random() - 0.5) * player.w,
        player.y + (Math.random() - 0.5) * player.h,
        1, Math.random() < 0.5 ? COL.red : COL.orange, 20, 60, 0.2, 0.4, 2, 4
      );
    }
    if (rageTimer <= 0) {
      rageMode = false;
      rageMeter = 0;
      stopRageRumble();
      addFloatText(W / 2, H / 2, 'RAGE OVER', COL.dimWhite, 24, 1.0);
    }
  }

  // Screen effects decay
  screenShake = Math.max(0, screenShake - dt * 2);
  screenFlashR = Math.max(0, screenFlashR - dt * 3);
  screenFlashG = Math.max(0, screenFlashG - dt * 3);

  // Tire marks at high speed or during rage
  if (scrollSpeed > 280 || rageMode) {
    tireMarks.push({
      x: player.x - player.w / 2 + 4,
      y: player.y + player.h / 2,
      life: 1.5,
    });
    tireMarks.push({
      x: player.x + player.w / 2 - 4,
      y: player.y + player.h / 2,
      life: 1.5,
    });
  }

  // Update tire marks
  for (let i = tireMarks.length - 1; i >= 0; i--) {
    tireMarks[i].y += scrollSpeed * dt;
    tireMarks[i].life -= dt;
    if (tireMarks[i].life <= 0 || tireMarks[i].y > H + 20) {
      tireMarks.splice(i, 1);
    }
  }
  // Cap tire marks
  if (tireMarks.length > 200) tireMarks.splice(0, tireMarks.length - 200);

  // Engine sound
  updateEngineSound(scrollSpeed);

  // -- Spawn cars --
  carSpawnTimer -= dt;
  if (carSpawnTimer <= 0) {
    carSpawnTimer = getSpawnRate() * (0.7 + Math.random() * 0.6);
    spawnCar();
  }

  // -- Spawn collectibles --
  collectibleTimer -= dt;
  if (collectibleTimer <= 0) {
    collectibleTimer = 3 + Math.random() * 4;
    spawnCollectible();
  }

  // -- Spawn roadside --
  roadsideTimer -= dt;
  if (roadsideTimer <= 0) {
    roadsideTimer = 0.4 + Math.random() * 0.6;
    spawnRoadsideObject();
  }

  // -- Update cars --
  for (let i = cars.length - 1; i >= 0; i--) {
    const car = cars[i];
    updateCarBehavior(car, dt);

    // Remove offscreen
    if (car.y > H + 100 || car.y < -200 || car.x < -100 || car.x > W + 100) {
      cars.splice(i, 1);
      continue;
    }

    if (car.flyingOff) continue;

    // Check collision with player
    const playerBox = { x: player.x, y: player.y, w: player.w - 4, h: player.h - 4 };
    const carBox = { x: car.x, y: car.y, w: car.w - 2, h: car.h - 2 };

    if (boxCollide(playerBox, carBox)) {
      if (rageMode) {
        rageRamCar(car);
      } else if (player.invincibleTimer <= 0) {
        if (player.shielded) {
          player.shielded = false;
          player.invincibleTimer = 1.0;
          spawnSparks(player.x, player.y);
          playSound('shieldHit');
          addFloatText(player.x, player.y - 30, 'SHIELD!', COL.yellow, 16, 0.8);
          addRage(15);
          // Push car away
          car.y += 40;
        } else {
          player.health--;
          player.invincibleTimer = 1.5;
          addRage(15);
          screenShake = 0.4;
          screenFlashR = 0.3;
          spawnSparks((player.x + car.x) / 2, (player.y + car.y) / 2);
          playSound('crash');
          addFloatText(player.x, player.y - 30, '-1 HP', COL.red, 18, 1.0);
          comboCount = 0;
          comboTimer = 0;

          if (player.health <= 0) {
            gameOver();
            return;
          }
        }
      }
    } else {
      // Near miss check
      nearMissCheck(car);
    }
  }

  // -- Update collectibles --
  for (let i = collectibles.length - 1; i >= 0; i--) {
    const c = collectibles[i];
    c.y += scrollSpeed * dt * 0.8;
    c.bobTimer += dt * 4;

    if (c.y > H + 40) {
      collectibles.splice(i, 1);
      continue;
    }

    // Collect check
    const dx2 = player.x - c.x;
    const dy2 = player.y - c.y;
    if (Math.sqrt(dx2 * dx2 + dy2 * dy2) < 28) {
      playSound('pickup');
      switch (c.type) {
        case 'data':
          score += 100;
          addFloatText(c.x, c.y - 20, '+100', COL.cyan, 16, 0.8);
          break;
        case 'coffee':
          player.speedBoostTimer = 4;
          addFloatText(c.x, c.y - 20, 'SPEED BOOST!', COL.orange, 16, 1.0);
          break;
        case 'hardhat':
          player.shielded = true;
          addFloatText(c.x, c.y - 20, 'SHIELD!', COL.yellow, 16, 1.0);
          break;
        case 'wrench':
          if (player.health < player.maxHealth) {
            player.health++;
            addFloatText(c.x, c.y - 20, '+1 HP', COL.green, 16, 1.0);
          } else {
            score += 50;
            addFloatText(c.x, c.y - 20, '+50', COL.green, 14, 0.8);
          }
          break;
      }
      spawnParticles(c.x, c.y, 6, COL.cyan, 20, 60, 0.2, 0.4, 1, 3);
      collectibles.splice(i, 1);
    }
  }

  // -- Update roadside objects --
  for (let i = roadsideObjects.length - 1; i >= 0; i--) {
    roadsideObjects[i].y += scrollSpeed * dt * 0.85;
    if (roadsideObjects[i].y > H + 60) {
      roadsideObjects.splice(i, 1);
    }
  }

  // -- Update particles --
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.life -= dt;
    if (p.life <= 0) particles.splice(i, 1);
  }

  // -- Update float texts --
  for (let i = floatTexts.length - 1; i >= 0; i--) {
    const f = floatTexts[i];
    f.life -= dt;
    f.y -= 30 * dt;
    if (f.life <= 0) floatTexts.splice(i, 1);
  }

  // -- Score from distance --
  score += dt * (scrollSpeed * 0.02);
}

// ============================================================
//  GAME OVER
// ============================================================
function gameOver() {
  state = STATE.GAME_OVER;
  gameOverTimer = 0;
  playSound('gameOver');
  stopRageRumble();
  spawnExplosion(player.x, player.y);
  screenShake = 0.8;

  if (engineGain && audioCtx) {
    engineGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.1);
  }

  var finalScore = Math.floor(score);
  setTimeout(function() {
    if (typeof CyvlLeaderboard !== 'undefined') {
      CyvlLeaderboard.show('road-rage', finalScore);
    }
    leaderboardShown = true;
  }, 600);
}

function updateGameOver(dt) {
  gameOverTimer += dt;
  // Keep particles alive
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.life -= dt;
    if (p.life <= 0) particles.splice(i, 1);
  }
  for (let i = floatTexts.length - 1; i >= 0; i--) {
    floatTexts[i].life -= dt;
    floatTexts[i].y -= 20 * dt;
    if (floatTexts[i].life <= 0) floatTexts.splice(i, 1);
  }
  screenShake = Math.max(0, screenShake - dt * 2);
}

// ============================================================
//  TITLE SCREEN
// ============================================================
function updateTitle(dt) {
  titleTime += dt;

  // Animate title screen cars
  if (titleCars.length < 8) {
    if (Math.random() < dt * 2) {
      const lane = Math.floor(Math.random() * LANE_COUNT);
      titleCars.push({
        x: laneCenter(lane),
        y: -50,
        w: 26 + Math.random() * 12,
        h: 44 + Math.random() * 12,
        speed: 80 + Math.random() * 120,
        color: ['#cc2233', '#ddcc22', '#dd6622', '#2266ee', '#339944', '#9944cc', '#777788'][Math.floor(Math.random() * 7)],
      });
    }
  }
  for (let i = titleCars.length - 1; i >= 0; i--) {
    titleCars[i].y += titleCars[i].speed * dt;
    if (titleCars[i].y > H + 60) titleCars.splice(i, 1);
  }
}

// ============================================================
//  DRAW — ROAD & ENVIRONMENT
// ============================================================

// Pre-generate road texture noise (avoids flicker)
const roadNoise = [];
for (let i = 0; i < 800; i++) {
  roadNoise.push({
    x: ROAD_LEFT + Math.random() * ROAD_W,
    y: Math.random() * H,
    w: 4 + Math.random() * 8,
    h: 2 + Math.random() * 4,
    dark: Math.random() < 0.5,
  });
}
function drawRoad() {
  // Grass / shoulder areas
  ctx.fillStyle = '#1a2a1a';
  ctx.fillRect(0, 0, ROAD_LEFT - SHOULDER_W, H);
  ctx.fillRect(ROAD_RIGHT + SHOULDER_W, 0, W - ROAD_RIGHT - SHOULDER_W, H);

  // Shoulder gravel
  ctx.fillStyle = '#3a3a3a';
  ctx.fillRect(ROAD_LEFT - SHOULDER_W, 0, SHOULDER_W, H);
  ctx.fillRect(ROAD_RIGHT, 0, SHOULDER_W, H);

  // Road asphalt
  ctx.fillStyle = '#2a2a2e';
  ctx.fillRect(ROAD_LEFT, 0, ROAD_W, H);

  // Subtle road texture (pre-generated to avoid flicker)
  ctx.globalAlpha = 0.04;
  for (let i = 0; i < roadNoise.length; i++) {
    const n = roadNoise[i];
    ctx.fillStyle = n.dark ? '#444' : '#222';
    ctx.fillRect(n.x, n.y, n.w, n.h);
  }
  ctx.globalAlpha = 1;

  // Yellow edge lines (solid)
  ctx.fillStyle = '#ccaa00';
  ctx.fillRect(ROAD_LEFT - 2, 0, 4, H);
  ctx.fillRect(ROAD_RIGHT - 2, 0, 4, H);

  // White dashed lane markings
  const dashLen = 40;
  const gapLen = 30;
  const totalLen = dashLen + gapLen;
  const offset = roadOffset % totalLen;

  ctx.fillStyle = '#ffffff';
  for (let lane = 1; lane < LANE_COUNT; lane++) {
    const x = ROAD_LEFT + lane * LANE_W - 1;
    for (let y = -offset - dashLen; y < H + dashLen; y += totalLen) {
      ctx.fillRect(x, y, 2, dashLen);
    }
  }

  // Guardrails
  drawGuardrail(ROAD_LEFT - SHOULDER_W - 4, 0, H);
  drawGuardrail(ROAD_RIGHT + SHOULDER_W, 0, H);
}

function drawGuardrail(x, y, height) {
  ctx.fillStyle = '#666';
  ctx.fillRect(x, y, 4, height);

  // Posts
  const postSpacing = 60;
  const offset = roadOffset % postSpacing;
  ctx.fillStyle = '#888';
  for (let py = -offset; py < height; py += postSpacing) {
    ctx.fillRect(x - 1, py, 6, 8);
  }
}

function drawRoadsideObjects() {
  for (let i = 0; i < roadsideObjects.length; i++) {
    const obj = roadsideObjects[i];
    ctx.save();
    ctx.translate(obj.x, obj.y);

    switch (obj.type) {
      case 'tree':
        // Trunk
        ctx.fillStyle = '#553311';
        ctx.fillRect(-3, -4, 6, 12);
        // Canopy
        ctx.fillStyle = '#226633';
        ctx.beginPath();
        ctx.arc(0, -6, 12, 0, Math.PI * 2);
        ctx.fill();
        if (nightMode) {
          ctx.fillStyle = '#113322';
          ctx.globalAlpha = 0.4;
          ctx.beginPath();
          ctx.arc(0, -6, 12, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1;
        }
        break;
      case 'sign':
        ctx.fillStyle = '#666';
        ctx.fillRect(-1, -8, 2, 16);
        ctx.fillStyle = '#336633';
        ctx.fillRect(-10, -12, 20, 10);
        ctx.fillStyle = COL.white;
        ctx.font = '6px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('EXIT', 0, -5);
        break;
      case 'lamppost':
        ctx.fillStyle = '#555';
        ctx.fillRect(-1, -12, 2, 20);
        ctx.fillStyle = '#777';
        ctx.fillRect(-4, -14, 8, 3);
        if (nightMode) {
          ctx.fillStyle = 'rgba(255,220,100,0.15)';
          ctx.beginPath();
          ctx.arc(0, -10, 30, 0, Math.PI * 2);
          ctx.fill();
        }
        break;
      case 'barrier':
        ctx.fillStyle = '#aa4400';
        ctx.fillRect(-8, -3, 16, 6);
        ctx.fillStyle = '#ffaa00';
        ctx.fillRect(-8, -3, 8, 6);
        break;
    }
    ctx.restore();
  }
}

// ============================================================
//  DRAW — VEHICLES
// ============================================================
function drawPlayerVan() {
  ctx.save();
  ctx.translate(player.x, player.y);

  // Invincibility blink
  if (player.invincibleTimer > 0 && !rageMode) {
    if (Math.floor(player.invincibleTimer * 10) % 2 === 0) {
      ctx.globalAlpha = 0.5;
    }
  }

  // Shield glow
  if (player.shielded) {
    ctx.strokeStyle = COL.yellow;
    ctx.lineWidth = 2;
    ctx.globalAlpha = 0.5 + Math.sin(Date.now() * 0.01) * 0.3;
    ctx.beginPath();
    ctx.ellipse(0, 0, player.w / 2 + 6, player.h / 2 + 6, 0, 0, Math.PI * 2);
    ctx.stroke();
    ctx.globalAlpha = 1;
  }

  // Rage glow
  if (rageMode) {
    ctx.shadowColor = COL.red;
    ctx.shadowBlur = 20;
    ctx.fillStyle = 'rgba(255,34,68,0.2)';
    ctx.fillRect(-player.w / 2 - 8, -player.h / 2 - 8, player.w + 16, player.h + 16);
    ctx.shadowBlur = 0;
  }

  const hw = player.w / 2;
  const hh = player.h / 2;

  // Van body
  ctx.fillStyle = rageMode ? '#ff4444' : '#e8e8ee';
  ctx.fillRect(-hw, -hh, player.w, player.h);

  // CYVL cyan stripe
  ctx.fillStyle = rageMode ? '#ff6600' : COL.cyan;
  ctx.fillRect(-hw, -hh + 10, player.w, 4);
  ctx.fillRect(-hw, hh - 14, player.w, 4);

  // Windshield (front — top of van since top-down facing up)
  ctx.fillStyle = '#335577';
  ctx.fillRect(-hw + 4, -hh + 2, player.w - 8, 8);

  // Rear window
  ctx.fillStyle = '#223344';
  ctx.fillRect(-hw + 6, hh - 8, player.w - 12, 6);

  // Wheels
  ctx.fillStyle = '#222';
  ctx.fillRect(-hw - 3, -hh + 8, 5, 10);
  ctx.fillRect(hw - 2, -hh + 8, 5, 10);
  ctx.fillRect(-hw - 3, hh - 18, 5, 10);
  ctx.fillRect(hw - 2, hh - 18, 5, 10);

  // LiDAR dome on roof
  ctx.fillStyle = '#aabbcc';
  ctx.beginPath();
  ctx.arc(0, -4, 6, 0, Math.PI * 2);
  ctx.fill();

  // LiDAR spinning dot
  const ldx = Math.cos(player.lidarAngle) * 5;
  const ldy = Math.sin(player.lidarAngle) * 5;
  ctx.fillStyle = rageMode ? COL.red : COL.cyan;
  ctx.beginPath();
  ctx.arc(ldx, -4 + ldy, 2, 0, Math.PI * 2);
  ctx.fill();

  // Survey equipment
  ctx.fillStyle = '#889';
  ctx.fillRect(-4, 4, 8, 4);
  ctx.fillRect(-2, 10, 4, 6);

  // Headlights
  if (nightMode) {
    ctx.fillStyle = 'rgba(255,255,200,0.3)';
    ctx.beginPath();
    ctx.moveTo(-hw + 3, -hh);
    ctx.lineTo(-hw - 10, -hh - 80);
    ctx.lineTo(hw + 10, -hh - 80);
    ctx.lineTo(hw - 3, -hh);
    ctx.fill();
  }

  // Taillights
  ctx.fillStyle = '#ff3333';
  ctx.fillRect(-hw + 2, hh - 3, 5, 3);
  ctx.fillRect(hw - 7, hh - 3, 5, 3);

  ctx.restore();
}

function drawCar(car) {
  ctx.save();
  ctx.translate(car.x, car.y);

  if (car.flyingOff) {
    ctx.rotate(car.spinAngle);
    ctx.globalAlpha = 0.7;
  }

  const hw = car.w / 2;
  const hh = car.h / 2;

  // Body
  ctx.fillStyle = car.color;
  ctx.fillRect(-hw, -hh, car.w, car.h);

  // Darken edges for depth
  ctx.fillStyle = 'rgba(0,0,0,0.2)';
  ctx.fillRect(-hw, -hh, 3, car.h);
  ctx.fillRect(hw - 3, -hh, 3, car.h);

  // Windshield
  ctx.fillStyle = '#223355';
  if (car.type === CAR_TYPES.WRONG_WAY) {
    // Facing us — windshield at bottom
    ctx.fillRect(-hw + 3, hh - 10, car.w - 6, 8);
  } else {
    ctx.fillRect(-hw + 3, -hh + 3, car.w - 6, 8);
  }

  // Rear window
  if (car.type === CAR_TYPES.WRONG_WAY) {
    ctx.fillStyle = '#112233';
    ctx.fillRect(-hw + 5, -hh + 3, car.w - 10, 6);
  } else {
    ctx.fillStyle = '#112233';
    ctx.fillRect(-hw + 5, hh - 9, car.w - 10, 6);
  }

  // Wheels
  ctx.fillStyle = '#111';
  ctx.fillRect(-hw - 2, -hh + 6, 4, 8);
  ctx.fillRect(hw - 2, -hh + 6, 4, 8);
  ctx.fillRect(-hw - 2, hh - 14, 4, 8);
  ctx.fillRect(hw - 2, hh - 14, 4, 8);

  // Taillights (red at bottom for normal, headlights for wrong-way)
  if (car.type === CAR_TYPES.WRONG_WAY) {
    // Headlights facing us
    ctx.fillStyle = car.flashTimer > 0 ? '#ffffff' : '#ffff88';
    ctx.fillRect(-hw + 2, hh - 4, 5, 3);
    ctx.fillRect(hw - 7, hh - 4, 5, 3);
    // Night headlight beams
    if (nightMode) {
      ctx.fillStyle = 'rgba(255,255,200,0.15)';
      ctx.beginPath();
      ctx.moveTo(-hw + 3, hh);
      ctx.lineTo(-hw - 15, hh + 100);
      ctx.lineTo(hw + 15, hh + 100);
      ctx.lineTo(hw - 3, hh);
      ctx.fill();
    }
  } else {
    ctx.fillStyle = '#cc1111';
    ctx.fillRect(-hw + 2, hh - 3, 4, 3);
    ctx.fillRect(hw - 6, hh - 3, 4, 3);

    // Headlights at front
    if (nightMode) {
      ctx.fillStyle = 'rgba(255,255,200,0.08)';
      ctx.beginPath();
      ctx.moveTo(-hw + 3, -hh);
      ctx.lineTo(-hw - 8, -hh - 50);
      ctx.lineTo(hw + 8, -hh - 50);
      ctx.lineTo(hw - 3, -hh);
      ctx.fill();
    }
  }

  // Tailgater flashing headlights
  if (car.type === CAR_TYPES.TAILGATER && car.flashTimer > 0) {
    ctx.fillStyle = Math.floor(car.flashTimer * 20) % 2 === 0 ? '#ffffff' : '#ffff44';
    ctx.fillRect(-hw + 2, -hh, 5, 4);
    ctx.fillRect(hw - 7, -hh, 5, 4);
  }

  // Road hog truck bed markings
  if (car.type === CAR_TYPES.ROAD_HOG) {
    ctx.fillStyle = 'rgba(0,0,0,0.15)';
    ctx.fillRect(-hw + 4, -hh + 14, car.w - 8, car.h - 22);
    ctx.strokeStyle = '#226633';
    ctx.lineWidth = 1;
    ctx.strokeRect(-hw + 4, -hh + 14, car.w - 8, car.h - 22);
  }

  // Speed demon racing stripes
  if (car.type === CAR_TYPES.SPEED_DEMON) {
    ctx.fillStyle = 'rgba(255,255,255,0.25)';
    ctx.fillRect(-2, -hh, 1, car.h);
    ctx.fillRect(2, -hh, 1, car.h);
  }

  ctx.restore();
}

// ============================================================
//  DRAW — COLLECTIBLES
// ============================================================
function drawCollectibles() {
  for (let i = 0; i < collectibles.length; i++) {
    const c = collectibles[i];
    const bob = Math.sin(c.bobTimer) * 3;
    ctx.save();
    ctx.translate(c.x, c.y + bob);

    switch (c.type) {
      case 'data':
        // Cyan diamond
        ctx.fillStyle = COL.cyan;
        ctx.shadowColor = COL.cyan;
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.moveTo(0, -c.size / 2);
        ctx.lineTo(c.size / 2, 0);
        ctx.lineTo(0, c.size / 2);
        ctx.lineTo(-c.size / 2, 0);
        ctx.closePath();
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.fillStyle = COL.white;
        ctx.globalAlpha = 0.5;
        ctx.beginPath();
        ctx.moveTo(0, -c.size / 2 + 2);
        ctx.lineTo(c.size / 4, 0);
        ctx.lineTo(0, 2);
        ctx.lineTo(-c.size / 4, 0);
        ctx.closePath();
        ctx.fill();
        ctx.globalAlpha = 1;
        break;
      case 'coffee':
        // Brown coffee cup
        ctx.fillStyle = '#664422';
        ctx.fillRect(-5, -6, 10, 12);
        ctx.fillStyle = '#553311';
        ctx.fillRect(-6, -7, 12, 3);
        // Steam
        ctx.strokeStyle = 'rgba(255,255,255,0.4)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-2, -8);
        ctx.quadraticCurveTo(-3, -13, 0, -14);
        ctx.moveTo(2, -8);
        ctx.quadraticCurveTo(3, -13, 0, -15);
        ctx.stroke();
        break;
      case 'hardhat':
        // Yellow hard hat
        ctx.fillStyle = COL.yellow;
        ctx.beginPath();
        ctx.ellipse(0, 0, 8, 6, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#ccaa00';
        ctx.fillRect(-8, 0, 16, 3);
        break;
      case 'wrench':
        // Silver wrench
        ctx.fillStyle = '#aabbcc';
        ctx.fillRect(-2, -8, 4, 16);
        ctx.fillStyle = '#8899aa';
        ctx.beginPath();
        ctx.arc(0, -8, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#aabbcc';
        ctx.beginPath();
        ctx.arc(0, -8, 2, 0, Math.PI * 2);
        ctx.fill();
        break;
    }
    ctx.restore();
  }
}

// ============================================================
//  DRAW — HUD
// ============================================================
function drawHUD() {
  // Score (offset right to avoid rage meter overlap)
  ctx.fillStyle = COL.cyan;
  ctx.font = 'bold 20px Courier New';
  ctx.textAlign = 'left';
  ctx.fillText('SCORE', 42, 24);
  ctx.font = 'bold 26px Courier New';
  ctx.fillText(Math.floor(score).toLocaleString(), 42, 52);

  // Speed
  ctx.textAlign = 'center';
  ctx.fillStyle = COL.dimWhite;
  ctx.font = '12px Courier New';
  ctx.fillText('SPEED', W / 2, 18);
  ctx.fillStyle = COL.white;
  ctx.font = 'bold 22px Courier New';
  ctx.fillText(Math.floor(displaySpeed) + ' MPH', W / 2, 40);

  // Speed bar
  const speedBarW = 120;
  const speedBarH = 6;
  const speedBarX = W / 2 - speedBarW / 2;
  ctx.fillStyle = '#222';
  ctx.fillRect(speedBarX, 46, speedBarW, speedBarH);
  const speedFill = Math.min(1, displaySpeed / 180);
  const speedColor = speedFill > 0.7 ? COL.red : speedFill > 0.4 ? COL.orange : COL.green;
  ctx.fillStyle = speedColor;
  ctx.fillRect(speedBarX, 46, speedBarW * speedFill, speedBarH);

  // Distance
  ctx.fillStyle = COL.dimWhite;
  ctx.font = '11px Courier New';
  ctx.fillText(Math.floor(distance) + ' m', W / 2, 64);

  // Health bar
  ctx.textAlign = 'right';
  ctx.fillStyle = COL.dimWhite;
  ctx.font = '12px Courier New';
  ctx.fillText('HEALTH', W - 15, 18);
  const hpBarW = 120;
  const hpBarX = W - 15 - hpBarW;
  ctx.fillStyle = '#222';
  ctx.fillRect(hpBarX, 24, hpBarW, 12);
  for (let i = 0; i < player.maxHealth; i++) {
    const segW = hpBarW / player.maxHealth - 2;
    const sx = hpBarX + i * (hpBarW / player.maxHealth) + 1;
    if (i < player.health) {
      const hpPct = player.health / player.maxHealth;
      ctx.fillStyle = hpPct > 0.6 ? COL.green : hpPct > 0.3 ? COL.yellow : COL.red;
    } else {
      ctx.fillStyle = '#331111';
    }
    ctx.fillRect(sx, 25, segW, 10);
  }

  // Shield indicator
  if (player.shielded) {
    ctx.fillStyle = COL.yellow;
    ctx.font = 'bold 11px Courier New';
    ctx.fillText('SHIELD ACTIVE', W - 15, 50);
  }

  // Speed boost indicator
  if (player.speedBoostTimer > 0) {
    ctx.fillStyle = COL.orange;
    ctx.font = 'bold 11px Courier New';
    ctx.textAlign = 'right';
    ctx.fillText('BOOST ' + player.speedBoostTimer.toFixed(1) + 's', W - 15, player.shielded ? 62 : 50);
  }

  // Honk cooldown
  if (player.honkCooldown > 0) {
    ctx.fillStyle = COL.dimWhite;
    ctx.font = '10px Courier New';
    ctx.textAlign = 'right';
    ctx.fillText('HORN: ' + Math.ceil(player.honkCooldown) + 's', W - 15, H - 15);
  } else {
    ctx.fillStyle = COL.white;
    ctx.font = '10px Courier New';
    ctx.textAlign = 'right';
    ctx.fillText('HORN: READY', W - 15, H - 15);
  }

  // -- RAGE METER (left side vertical bar) --
  drawRageMeter();

  // -- COMBO indicator --
  if (comboCount > 0 && comboTimer > 0) {
    const comboAlpha = Math.min(1, comboTimer / 0.5);
    ctx.globalAlpha = comboAlpha;
    ctx.textAlign = 'center';
    let comboLabel, comboColor;
    if (comboCount >= 5) { comboLabel = 'GODLIKE!'; comboColor = COL.red; }
    else if (comboCount === 4) { comboLabel = 'LEGENDARY!'; comboColor = COL.gold; }
    else if (comboCount === 3) { comboLabel = 'INSANE!'; comboColor = COL.orange; }
    else if (comboCount === 2) { comboLabel = 'RISKY!'; comboColor = COL.yellow; }
    else { comboLabel = 'CLOSE!'; comboColor = COL.green; }
    ctx.fillStyle = comboColor;
    ctx.font = 'bold ' + (16 + comboCount * 2) + 'px Courier New';
    ctx.fillText(comboLabel + ' x' + comboCount, W / 2, 82);
    ctx.globalAlpha = 1;
  }

  // Rage mode timer
  if (rageMode) {
    ctx.textAlign = 'center';
    ctx.fillStyle = COL.red;
    ctx.font = 'bold 20px Courier New';
    const rageFlash = Math.sin(Date.now() * 0.015) > 0;
    if (rageFlash) {
      ctx.fillText('RAGE MODE: ' + rageTimer.toFixed(1) + 's', W / 2, H - 20);
    }
  }
}

function drawRageMeter() {
  const barX = 12;
  const barY = 90;
  const barW = 18;
  const barH = 280;

  // Label
  ctx.save();
  ctx.translate(barX + barW / 2, barY - 8);
  ctx.fillStyle = COL.dimWhite;
  ctx.font = 'bold 10px Courier New';
  ctx.textAlign = 'center';
  ctx.fillText('RAGE', 0, 0);
  ctx.restore();

  // Background
  ctx.fillStyle = '#111';
  ctx.fillRect(barX, barY, barW, barH);
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 1;
  ctx.strokeRect(barX, barY, barW, barH);

  // Fill
  const fillH = (rageMeter / 100) * barH;
  const fillY = barY + barH - fillH;

  // Gradient color based on level
  let fillColor;
  if (rageMeter < 33) fillColor = COL.cyan;
  else if (rageMeter < 66) fillColor = COL.orange;
  else fillColor = COL.red;

  ctx.fillStyle = fillColor;
  ctx.fillRect(barX + 1, fillY, barW - 2, fillH);

  // Glow when full
  if (rageMeter >= 100 && !rageMode) {
    const pulse = Math.sin(Date.now() * 0.008) * 0.3 + 0.7;
    ctx.fillStyle = `rgba(255,34,68,${pulse * 0.3})`;
    ctx.fillRect(barX - 4, barY - 4, barW + 8, barH + 8);

    ctx.fillStyle = COL.red;
    ctx.font = 'bold 10px Courier New';
    ctx.textAlign = 'center';
    const flash = Math.sin(Date.now() * 0.01) > 0;
    if (flash) {
      ctx.fillText('RAGE', barX + barW / 2, barY + barH + 14);
      ctx.fillText('READY!', barX + barW / 2, barY + barH + 26);
    }
  }

  // Rage mode active indicator
  if (rageMode) {
    const pulse = Math.sin(Date.now() * 0.012) * 0.4 + 0.6;
    ctx.fillStyle = `rgba(255,34,68,${pulse})`;
    ctx.fillRect(barX, barY, barW, barH);

    ctx.fillStyle = COL.white;
    ctx.font = 'bold 10px Courier New';
    ctx.textAlign = 'center';
    ctx.fillText('RAGE', barX + barW / 2, barY + barH + 14);
    ctx.fillText('ON!', barX + barW / 2, barY + barH + 26);
  }

  // Tick marks
  ctx.fillStyle = '#555';
  for (let i = 1; i < 4; i++) {
    const ty = barY + (barH / 4) * i;
    ctx.fillRect(barX, ty, barW, 1);
  }
}

// ============================================================
//  DRAW — EFFECTS
// ============================================================
function drawParticles() {
  for (let i = 0; i < particles.length; i++) {
    const p = particles[i];
    const alpha = Math.max(0, p.life / p.maxLife);
    ctx.globalAlpha = alpha;
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
  }
  ctx.globalAlpha = 1;
}

function drawFloatTexts() {
  for (let i = 0; i < floatTexts.length; i++) {
    const f = floatTexts[i];
    const alpha = Math.max(0, f.life / f.maxLife);
    ctx.globalAlpha = alpha;
    ctx.fillStyle = f.color;
    ctx.font = 'bold ' + f.size + 'px Courier New';
    ctx.textAlign = 'center';
    ctx.fillText(f.text, f.x, f.y);
  }
  ctx.globalAlpha = 1;
}

function drawSpeedLines() {
  if (scrollSpeed < 250) return;
  const intensity = Math.min(1, (scrollSpeed - 250) / 300);
  ctx.globalAlpha = intensity * 0.2;
  ctx.strokeStyle = COL.white;
  ctx.lineWidth = 1;
  const lineCount = Math.floor(intensity * 10);
  for (let i = 0; i < lineCount; i++) {
    const x = Math.random() < 0.5 ?
      Math.random() * (ROAD_LEFT - 20) :
      ROAD_RIGHT + 20 + Math.random() * (W - ROAD_RIGHT - 20);
    const y = Math.random() * H;
    const len = 20 + Math.random() * 40;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x, y + len);
    ctx.stroke();
  }
  ctx.globalAlpha = 1;
}

function drawCRTOverlay() {
  // Scanlines
  ctx.fillStyle = 'rgba(0,0,0,0.06)';
  for (let y = 0; y < H; y += 3) {
    ctx.fillRect(0, y, W, 1);
  }

  // Vignette
  const grad = ctx.createRadialGradient(W / 2, H / 2, W * 0.3, W / 2, H / 2, W * 0.7);
  grad.addColorStop(0, 'rgba(0,0,0,0)');
  grad.addColorStop(1, 'rgba(0,0,0,0.35)');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);
}

function drawScreenFlash() {
  if (screenFlashR > 0) {
    ctx.fillStyle = `rgba(255,0,0,${screenFlashR * 0.4})`;
    ctx.fillRect(0, 0, W, H);
  }
  if (screenFlashG > 0) {
    ctx.fillStyle = `rgba(255,215,0,${screenFlashG * 0.3})`;
    ctx.fillRect(0, 0, W, H);
  }
}

function drawNightOverlay() {
  if (nightAlpha > 0) {
    ctx.fillStyle = `rgba(0,0,30,${nightAlpha})`;
    ctx.fillRect(0, 0, W, H);
  }
}

function drawRageTint() {
  if (rageMode) {
    const pulse = Math.sin(Date.now() * 0.006) * 0.05 + 0.1;
    ctx.fillStyle = `rgba(255,0,0,${pulse})`;
    ctx.fillRect(0, 0, W, H);
  }
}

// ============================================================
//  DRAW — GAME SCENE
// ============================================================
function drawTireMarks() {
  for (let i = 0; i < tireMarks.length; i++) {
    const t = tireMarks[i];
    ctx.globalAlpha = Math.min(0.25, t.life * 0.2);
    ctx.fillStyle = '#111';
    ctx.fillRect(t.x - 1, t.y, 3, 6);
  }
  ctx.globalAlpha = 1;
}

function drawGame() {
  drawRoad();
  drawTireMarks();
  drawRoadsideObjects();
  drawSpeedLines();
  drawCollectibles();

  // Draw cars behind player
  for (let i = 0; i < cars.length; i++) {
    if (cars[i].y > player.y) drawCar(cars[i]);
  }

  drawPlayerVan();

  // Draw cars in front of player
  for (let i = 0; i < cars.length; i++) {
    if (cars[i].y <= player.y) drawCar(cars[i]);
  }

  drawParticles();
  drawFloatTexts();
  drawNightOverlay();
  drawRageTint();
  drawScreenFlash();
  drawHUD();
  drawCRTOverlay();
}

// ============================================================
//  DRAW — TITLE SCREEN
// ============================================================
function drawTitle() {
  // Road preview
  drawRoad();
  for (let i = 0; i < titleCars.length; i++) {
    ctx.save();
    ctx.translate(titleCars[i].x, titleCars[i].y);
    ctx.fillStyle = titleCars[i].color;
    ctx.fillRect(-titleCars[i].w / 2, -titleCars[i].h / 2, titleCars[i].w, titleCars[i].h);
    ctx.fillStyle = '#223355';
    ctx.fillRect(-titleCars[i].w / 2 + 3, -titleCars[i].h / 2 + 3, titleCars[i].w - 6, 7);
    ctx.fillStyle = '#111';
    ctx.fillRect(-titleCars[i].w / 2 - 2, -titleCars[i].h / 2 + 6, 4, 8);
    ctx.fillRect(titleCars[i].w / 2 - 2, -titleCars[i].h / 2 + 6, 4, 8);
    ctx.restore();
  }

  // Dark overlay
  ctx.fillStyle = 'rgba(10,10,26,0.75)';
  ctx.fillRect(0, 0, W, H);

  // Title: "ROAD RAGE" with fire effect
  ctx.textAlign = 'center';

  // Fire glow behind text
  const fireGlow = Math.sin(titleTime * 3) * 10 + 20;
  ctx.shadowColor = COL.red;
  ctx.shadowBlur = fireGlow;
  ctx.fillStyle = COL.red;
  ctx.font = 'bold 72px Courier New';
  ctx.fillText('ROAD RAGE', W / 2, 200);
  ctx.shadowBlur = 0;

  // Fire particles above title
  ctx.globalAlpha = 0.6;
  for (let i = 0; i < 15; i++) {
    const fx = W / 2 - 180 + Math.random() * 360;
    const fy = 170 - Math.random() * 40 - Math.sin(titleTime * 4 + i) * 10;
    const fs = 2 + Math.random() * 4;
    ctx.fillStyle = Math.random() < 0.5 ? COL.orange : COL.yellow;
    ctx.fillRect(fx, fy, fs, fs);
  }
  ctx.globalAlpha = 1;

  // Subtitle
  ctx.fillStyle = COL.orange;
  ctx.font = 'bold 24px Courier New';
  ctx.fillText('HIGHWAY HAVOC', W / 2, 240);

  // Divider line
  ctx.strokeStyle = COL.darkCyan;
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(W / 2 - 180, 260);
  ctx.lineTo(W / 2 + 180, 260);
  ctx.stroke();

  // Van preview
  ctx.save();
  ctx.translate(W / 2, 310);
  // Simple van
  ctx.fillStyle = '#e8e8ee';
  ctx.fillRect(-17, -28, 34, 56);
  ctx.fillStyle = COL.cyan;
  ctx.fillRect(-17, -18, 34, 4);
  ctx.fillRect(-17, 14, 34, 4);
  ctx.fillStyle = '#335577';
  ctx.fillRect(-13, -26, 26, 8);
  ctx.fillStyle = '#aabbcc';
  ctx.beginPath();
  ctx.arc(0, -4, 6, 0, Math.PI * 2);
  ctx.fill();
  const ldx = Math.cos(titleTime * 4) * 5;
  const ldy = Math.sin(titleTime * 4) * 5;
  ctx.fillStyle = COL.cyan;
  ctx.beginPath();
  ctx.arc(ldx, -4 + ldy, 2, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();

  // Label
  ctx.fillStyle = COL.cyan;
  ctx.font = '12px Courier New';
  ctx.fillText('CYVL SURVEY VAN', W / 2, 355);

  // Controls
  ctx.fillStyle = COL.dimWhite;
  ctx.font = '13px Courier New';
  const controlY = 400;
  ctx.fillText('CONTROLS:', W / 2, controlY);
  ctx.font = '12px Courier New';
  ctx.fillText('ARROWS / WASD — Move', W / 2, controlY + 22);
  ctx.fillText('SPACE — Honk Horn (scares tailgaters)', W / 2, controlY + 40);
  ctx.fillText('SHIFT — Activate RAGE MODE (when full)', W / 2, controlY + 58);

  // Features
  ctx.fillStyle = COL.orange;
  ctx.font = '11px Courier New';
  ctx.fillText('Dodge traffic  |  Build RAGE METER  |  Near-miss combos', W / 2, controlY + 90);
  ctx.fillText('Collect survey data  |  Survive the highway chaos', W / 2, controlY + 106);

  // Start prompt
  const blink = Math.sin(titleTime * 4) > 0;
  if (blink) {
    ctx.fillStyle = COL.green;
    ctx.font = 'bold 20px Courier New';
    ctx.fillText('PRESS ENTER TO DRIVE', W / 2, 570);
  }

  // Footer
  ctx.fillStyle = '#334';
  ctx.font = '10px Courier New';
  ctx.fillText('A CYVL ARCADE GAME — cyvl.world', W / 2, H - 20);

  drawCRTOverlay();
}

// ============================================================
//  DRAW — GAME OVER SCREEN
// ============================================================
function drawGameOver() {
  // Keep the last game frame dimmed
  ctx.fillStyle = 'rgba(10,10,26,0.85)';
  ctx.fillRect(0, 0, W, H);

  ctx.textAlign = 'center';

  // "GAME OVER" with red glow
  ctx.shadowColor = COL.red;
  ctx.shadowBlur = 20;
  ctx.fillStyle = COL.red;
  ctx.font = 'bold 52px Courier New';
  ctx.fillText('GAME OVER', W / 2, 160);
  ctx.shadowBlur = 0;

  // Stats
  ctx.fillStyle = COL.dimWhite;
  ctx.font = '14px Courier New';
  const statY = 220;
  const lineH = 28;

  ctx.fillStyle = COL.cyan;
  ctx.font = 'bold 16px Courier New';
  ctx.fillText('FINAL SCORE: ' + Math.floor(score).toLocaleString(), W / 2, statY);

  ctx.fillStyle = COL.dimWhite;
  ctx.font = '13px Courier New';
  ctx.fillText('Distance: ' + Math.floor(distance) + ' m', W / 2, statY + lineH);
  ctx.fillText('Max Speed: ' + Math.floor(40 + (200 + distance * 0.02) * 0.25) + ' MPH', W / 2, statY + lineH * 2);
  ctx.fillText('Cars Dodged: ' + carsDodged, W / 2, statY + lineH * 3);
  ctx.fillText('Best Combo: ' + bestCombo + 'x', W / 2, statY + lineH * 4);

  ctx.fillStyle = COL.red;
  ctx.fillText('Rage Activations: ' + rageActivations, W / 2, statY + lineH * 5);
  ctx.fillStyle = COL.orange;
  ctx.fillText('Cars Wrecked: ' + carsWrecked, W / 2, statY + lineH * 6);

  // Restart prompt
  if (gameOverTimer > 1.5) {
    const blink = Math.sin(gameOverTimer * 4) > 0;
    if (blink) {
      ctx.fillStyle = COL.green;
      ctx.font = 'bold 16px Courier New';
      ctx.fillText('PRESS ENTER TO CONTINUE', W / 2, 480);
    }
  }

  drawCRTOverlay();
}

// ============================================================
//  MAIN DRAW DISPATCH (for game over overlay)
// ============================================================
function drawFull() {
  ctx.save();

  let shakeX = 0, shakeY = 0;
  if (screenShake > 0) {
    shakeX = (Math.random() - 0.5) * screenShake * 16;
    shakeY = (Math.random() - 0.5) * screenShake * 16;
    ctx.translate(shakeX, shakeY);
  }

  ctx.fillStyle = COL.bg;
  ctx.fillRect(-10, -10, W + 20, H + 20);

  if (state === STATE.TITLE) {
    // Scroll road for title
    roadOffset += 2;
    drawTitle();
  } else if (state === STATE.PLAYING) {
    drawGame();
  } else if (state === STATE.GAME_OVER) {
    drawGame();
    drawGameOver();
  }

  ctx.restore();
}

// ============================================================
//  GAME LOOP (Delta Time)
// ============================================================
let lastTime = 0;

function gameLoop(timestamp) {
  if (!lastTime) lastTime = timestamp;
  const dt = Math.min((timestamp - lastTime) / 1000, 0.05);
  lastTime = timestamp;

  update(dt);
  drawFull();

  requestAnimationFrame(gameLoop);
}

requestAnimationFrame(gameLoop);

</script>
</body>
</html>
